"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = seempleError;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/* eslint-disable prefer-template, max-len */
var bindingErrorPrefix = 'Binding error:';
var calcErrorPrefix = 'Calc error:';
var eventsErrorPrefix = 'Events error:';
var arrayErrorPrefix = 'Seemple.Array error:';

var getType = function getType(variable) {
  if (variable === null) {
    return 'null';
  }

  return (0, _typeof2["default"])(variable);
};

var getTypeError = function getTypeError(variable, variableName, expectedType) {
  return "".concat(variableName, " must have type \"").concat(expectedType, "\" but got \"").concat(getType(variable), "\" instead.");
};

var errors = {
  'common:object_type': function commonObject_type(_ref) {
    var object = _ref.object,
        method = _ref.method;
    return "Error in ".concat(method, ": ") + getTypeError(object, 'object', 'object');
  },
  'common:call_class': function commonCall_class() {
    return 'Cannot call a class as a function';
  },
  'common:use_magic_props': function commonUse_magic_props() {
    return '"sandbox" key (for all objects) and "container" key (for Seemple.Array instances)' + ' are reserved for service use and cannot be used as usual properties';
  },
  'binding:node_missing': function bindingNode_missing(_ref2) {
    var key = _ref2.key,
        node = _ref2.node;
    var selectorInfo = typeof node === 'string' ? " (given selector is \"".concat(node, "\")") : '';
    return "".concat(bindingErrorPrefix, " node is missing for key \"").concat(key, "\"").concat(selectorInfo, ".");
  },
  'binding:falsy_key': function bindingFalsy_key() {
    return "".concat(bindingErrorPrefix, " \"key\" arg cannot be falsy");
  },
  'binding:instance_nodes_missing': function bindingInstance_nodes_missing(_ref3) {
    var $nodes = _ref3.$nodes;
    var missing = !$nodes ? '$nodes' : 'nodes';
    return "".concat(bindingErrorPrefix, " \"").concat(missing, "\" property of Seemple instance is missing.") + ' It must be an object and must not be reassigned.';
  },
  'binding:magic_props_nodes_length': function bindingMagic_props_nodes_length() {
    return "".concat(bindingErrorPrefix, " \"sandbox\" key (for all objects) and \"container\" key") + ' (for Seemple.Array instances) cannot have more than one bound node';
  },
  'calc:target_type': function calcTarget_type(_ref4) {
    var target = _ref4.target;
    return "".concat(calcErrorPrefix, " ").concat(getTypeError(target, 'target key', 'string'));
  },
  'calc:source_key_type': function calcSource_key_type(_ref5) {
    var sourceKey = _ref5.sourceKey;
    return "".concat(calcErrorPrefix, " ").concat(getTypeError(sourceKey, 'source key', 'string'));
  },
  'calc:source_object_type': function calcSource_object_type(_ref6) {
    var sourceObject = _ref6.sourceObject;
    return "".concat(calcErrorPrefix, " ").concat(getTypeError(sourceObject, 'source object', 'object'));
  },
  'calc:source_type': function calcSource_type(_ref7) {
    var source = _ref7.source;
    return "".concat(calcErrorPrefix, " ").concat(getTypeError(source, 'source', 'object'));
  },
  'array:model_type': function arrayModel_type(_ref8) {
    var Model = _ref8.Model;
    return "".concat(arrayErrorPrefix, " ").concat(getTypeError(Model, 'Model', 'function'));
  },
  'array:add_render_twice': function arrayAdd_render_twice() {
    return "".concat(arrayErrorPrefix, " one rendered object was inserted twice.");
  },
  'array:rendered_number_nodes': function arrayRendered_number_nodes(_ref9) {
    var length = _ref9.length;
    return "".concat(arrayErrorPrefix, " renderer returned ").concat(length, " nodes instead of one.") + " ".concat(length > 0 ? 'To fix this wrap these nodes by single node.' : '');
  },
  'array:renderer_node_missing': function arrayRenderer_node_missing(_ref10) {
    var selector = _ref10.selector;
    return "".concat(arrayErrorPrefix, " renderer node is missing (given selector is \"").concat(selector, "\")");
  },
  'array:nonexistent_method': function arrayNonexistent_method(_ref11) {
    var method = _ref11.method;
    return "".concat(arrayErrorPrefix, " Array.prototype.").concat(method, " doesn't exist.") + ' You need to include a polyfill for it (e. g. babel-node)';
  },
  'array:method_compat_renderer': function arrayMethod_compat_renderer(_ref12) {
    var method = _ref12.method;
    return "".concat(arrayErrorPrefix, " Not possible to render when ").concat(method, " method is called");
  },
  'pull:to_remove_type': function pullTo_remove_type(_ref13) {
    var toRemove = _ref13.toRemove;
    return "Error in pull: ".concat(getTypeError(toRemove, 'toRemove', 'number'));
  },
  'restore:no_nodes': function restoreNo_nodes() {
    return "".concat(arrayErrorPrefix, " cannot find any container to restore an instance using \"restore\" method");
  },
  'trigger:names_type': function triggerNames_type(_ref14) {
    var names = _ref14.names;
    return "".concat(eventsErrorPrefix, " ").concat(getTypeError(names, 'event name', 'string'));
  },
  'on:names_type': function onNames_type(_ref15) {
    var names = _ref15.names;
    return errors['trigger:names_type']({
      names: names
    });
  },
  'removedatakeys:key_type': function removedatakeysKey_type(_ref16) {
    var key = _ref16.key;
    return "Error in removeDataKeys: ".concat(getTypeError(key, 'key', 'string'));
  },
  'adddatakeys:key_type': function adddatakeysKey_type(_ref17) {
    var key = _ref17.key;
    return "Error in addDataKeys: ".concat(getTypeError(key, 'key', 'string'));
  },
  'remove:key_type': function removeKey_type(_ref18) {
    var key = _ref18.key;
    return "Error in remove: ".concat(getTypeError(key, 'key', 'string'));
  },
  'mediate:key_type': function mediateKey_type(_ref19) {
    var key = _ref19.key;
    return "Error in mediate: ".concat(getTypeError(key, 'key', 'string'));
  }
};

function seempleError(key, data) {
  var getError = errors[key];

  if (!getError) {
    throw Error("Unknown error \"".concat(key, "\". Please report about this on Github."));
  }

  return new Error(getError(data));
}
//# sourceMappingURL=seempleerror.js.map