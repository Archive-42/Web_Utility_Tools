"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = processRecreate;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _renderitemnode = _interopRequireDefault(require("./renderitemnode"));

var _triggerone = _interopRequireDefault(require("../../trigger/_triggerone"));

var _defs = _interopRequireDefault(require("../../_core/defs"));

var _seempleerror = _interopRequireDefault(require("../../_helpers/seempleerror"));

var _foreach = _interopRequireDefault(require("../../_helpers/foreach"));

var _getalreadyrendered = _interopRequireDefault(require("./getalreadyrendered"));

// this function renders inserted items if possible when recreate method is called
function processRecreate(_ref) {
  var self = _ref.self,
      selfDef = _ref.selfDef,
      eventOptions = _ref.eventOptions,
      container = _ref.container;
  var removed = eventOptions.removed,
      silent = eventOptions.silent;
  var selfId = selfDef.id; // iterate over removed items and remove their nodes

  (0, _foreach["default"])(removed, function (item) {
    var itemDef = _defs["default"].get(item);

    if (itemDef) {
      var renderedInArrays = itemDef.renderedInArrays;
      var node = renderedInArrays && renderedInArrays[selfId];

      if (node) {
        delete itemDef.renderedInArrays[selfId];
        container.removeChild(node);
      }
    }
  });
  var alreadyRenderedMap = {}; // iterate over all items
  // the following approach allows to throw an error when two added objects are the same
  // (not only compare existing items with old ones)

  (0, _foreach["default"])(self, function (item) {
    if (item && (0, _typeof2["default"])(item) === 'object') {
      var itemDef = _defs["default"].get(item);

      var alreadyRenderedNode;

      if (itemDef) {
        alreadyRenderedNode = (0, _getalreadyrendered["default"])({
          item: item,
          selfDef: selfDef
        });
      }

      if (alreadyRenderedNode) {
        // if an item is already rendered (old item)
        if (itemDef.id in alreadyRenderedMap) {
          // if an item is rendered twice throw an error
          throw (0, _seempleerror["default"])('array:add_render_twice');
        }

        alreadyRenderedMap[itemDef.id] = true;
        container.appendChild(alreadyRenderedNode);
      } else {
        // this is newly added item
        var _renderItemNode = (0, _renderitemnode["default"])({
          selfDef: selfDef,
          self: self,
          item: item,
          eventOptions: eventOptions
        }),
            node = _renderItemNode.node,
            itemEventOptions = _renderItemNode.itemEventOptions;

        if (node) {
          // itemDef is defined at renderItemNode if not defined before
          // reload this variable
          itemDef = itemDef || _defs["default"].get(item);

          if (itemDef.id in alreadyRenderedMap) {
            // if newly added item is rendered twice throw an error
            throw (0, _seempleerror["default"])('array:add_render_twice');
          }

          alreadyRenderedMap[itemDef.id] = true;
          container.appendChild(node);

          if (!silent) {
            (0, _triggerone["default"])(item, 'afterrender', itemEventOptions);
          }
        }
      }
    }
  });
}
//# sourceMappingURL=processrecreate.js.map