"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = processSpliceAdd;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _renderitemnode = _interopRequireDefault(require("./renderitemnode"));

var _triggerone = _interopRequireDefault(require("../../trigger/_triggerone"));

var _foreach = _interopRequireDefault(require("../../_helpers/foreach"));

var _checkalreadyrendered = _interopRequireDefault(require("./checkalreadyrendered"));

var _getalreadyrendered = _interopRequireDefault(require("./getalreadyrendered"));

// the function handles rendering of added items passed as third and rest arguments to splice method
function processSpliceAdd(_ref) {
  var self = _ref.self,
      selfDef = _ref.selfDef,
      eventOptions = _ref.eventOptions,
      container = _ref.container;
  var added = eventOptions.added,
      silent = eventOptions.silent;
  var nextIndex = self.lastIndexOf(added[added.length - 1]) + 1;
  var next = self[nextIndex];
  var nextNode; // get a node of an item which is placed next to the last added item
  // it is needed to insert newly rendered items before

  if (next && (0, _typeof2["default"])(next) === 'object') {
    nextNode = (0, _getalreadyrendered["default"])({
      item: next,
      selfDef: selfDef
    });
  }

  (0, _foreach["default"])(added, function (item) {
    if (item && (0, _typeof2["default"])(item) === 'object') {
      // throw an error if node of an item is alread rendered
      (0, _checkalreadyrendered["default"])({
        item: item,
        selfDef: selfDef
      });

      var _renderItemNode = (0, _renderitemnode["default"])({
        selfDef: selfDef,
        self: self,
        item: item,
        eventOptions: eventOptions
      }),
          node = _renderItemNode.node,
          itemEventOptions = _renderItemNode.itemEventOptions;

      if (node) {
        if (nextNode) {
          container.insertBefore(node, nextNode);
        } else {
          container.appendChild(node);
        }

        if (!silent) {
          (0, _triggerone["default"])(item, 'afterrender', itemEventOptions);
        }
      }
    }
  });
}
//# sourceMappingURL=processspliceadd.js.map