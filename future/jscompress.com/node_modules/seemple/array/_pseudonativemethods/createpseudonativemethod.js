"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = createPseudoNativeMethod;

var _toseemplearray = _interopRequireDefault(require("../_toseemplearray"));

var _createsortingmethod = _interopRequireDefault(require("./createsortingmethod"));

var _createremovingmethod = _interopRequireDefault(require("./createremovingmethod"));

var _createaddingmethod = _interopRequireDefault(require("./createaddingmethod"));

var _createsplice = _interopRequireDefault(require("./createsplice"));

var _createcopywithin = _interopRequireDefault(require("./createcopywithin"));

var _createfill = _interopRequireDefault(require("./createfill"));

var _apply = _interopRequireDefault(require("../../_helpers/apply"));

var _seempleerror = _interopRequireDefault(require("../../_helpers/seempleerror"));

var arrayPrototype = Array.prototype; // creates pseudo native method and returns it (push, push_, sort, sort_...)

function createPseudoNativeMethod(name) {
  var hasOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  switch (name) {
    case 'forEach':
      return function pseudoNativeMethod(callback, thisArg) {
        arrayPrototype[name].call(this, callback, thisArg); // return this for nicer chain calls

        return this;
      };

    case 'map':
    case 'filter':
    case 'slice':
      // TODO: Improve readability of pseudoNativeMethod, arguments "a, b" look not good
      return function pseudoNativeMethod(a, b) {
        return (0, _toseemplearray["default"])(arrayPrototype[name].call(this, a, b));
      };

    case 'every':
    case 'some':
    case 'findIndex':
    case 'find':
      return function pseudoNativeMethod(callback, thisArg) {
        var originalMethod = arrayPrototype[name];
        /* istanbul ignore if  */

        if (typeof originalMethod !== 'function') {
          throw (0, _seempleerror["default"])('array:nonexistent_method', {
            method: name
          });
        }

        return originalMethod.call(this, callback, thisArg);
      };

    case 'join':
      return function pseudoNativeMethod() {
        var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ',';
        return arrayPrototype[name].call(this, separator);
      };

    case 'indexOf':
    case 'lastIndexOf':
    case 'includes':
      return function pseudoNativeMethod(searchElement, fromIndex) {
        var originalMethod = arrayPrototype[name];
        /* istanbul ignore if  */

        if (typeof originalMethod !== 'function') {
          throw (0, _seempleerror["default"])('array:nonexistent_method', {
            method: name
          });
        }

        if (typeof fromIndex === 'undefined') {
          return originalMethod.call(this, searchElement);
        }

        return originalMethod.call(this, searchElement, fromIndex);
      };

    case 'reduce':
    case 'reduceRight':
      return function pseudoNativeMethod() {
        return (0, _apply["default"])(arrayPrototype[name], this, arguments);
      };

    case 'sort':
    case 'reverse':
      return (0, _createsortingmethod["default"])(name, hasOptions);

    case 'pop':
    case 'shift':
      return (0, _createremovingmethod["default"])(name, hasOptions);

    case 'push':
    case 'unshift':
      return (0, _createaddingmethod["default"])(name, hasOptions);

    case 'splice':
      return (0, _createsplice["default"])(hasOptions);

    case 'copyWithin':
      return (0, _createcopywithin["default"])(hasOptions);

    case 'fill':
      return (0, _createfill["default"])(hasOptions);

    default:
      return undefined;
  }
}
//# sourceMappingURL=createpseudonativemethod.js.map