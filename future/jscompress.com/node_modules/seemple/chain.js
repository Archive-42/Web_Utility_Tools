"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = chain;

var _checkobjecttype = _interopRequireDefault(require("./_helpers/checkobjecttype"));

var _foreach = _interopRequireDefault(require("./_helpers/foreach"));

var universalMethods = _interopRequireWildcard(require("./seemple/_universalmethods"));

var _class = _interopRequireDefault(require("./class"));

var _apply = _interopRequireDefault(require("./_helpers/apply"));

// create a prototype of ChainClass
// store target object at "object" property
var prototype = {
  constructor: function constructor(object) {
    this.object = object;
  }
};
var methodNames = Object.keys(universalMethods); // iterate over all universal methods

var _loop = function _loop(i) {
  var methodName = methodNames[i];
  var method = universalMethods[methodName]; // create every chained method

  prototype[methodName] = function chainedMethod() {
    var args = [this.object];
    (0, _foreach["default"])(arguments, function (argument) {
      args.push(argument);
    });
    (0, _apply["default"])(method, undefined, args); // returning this is important for chained calls

    return this;
  };
};

for (var i = 0; i < methodNames.length; i++) {
  _loop(i);
}

var ChainClass = (0, _class["default"])(prototype); // the function allows to chain static function calls on any object

function chain(object) {
  // check for type and throw an error if it is not an object and is not a function
  (0, _checkobjecttype["default"])(object, 'chain');
  return new ChainClass(object);
}
//# sourceMappingURL=chain.js.map