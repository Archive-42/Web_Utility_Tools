"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = bindNode;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _init = _interopRequireDefault(require("../_core/init"));

var _defineprop = _interopRequireDefault(require("../_core/defineprop"));

var _getnodes = _interopRequireDefault(require("./_getnodes"));

var _createbindingswitcher = _interopRequireDefault(require("./_createbindingswitcher"));

var _bindsinglenode = _interopRequireDefault(require("./_bindsinglenode"));

var _checkobjecttype = _interopRequireDefault(require("../_helpers/checkobjecttype"));

var _forown = _interopRequireDefault(require("../_helpers/forown"));

var _foreach = _interopRequireDefault(require("../_helpers/foreach"));

var _seempleerror = _interopRequireDefault(require("../_helpers/seempleerror"));

var _addtreelistener = _interopRequireDefault(require("../on/_addtreelistener"));

var _assign = _interopRequireDefault(require("../_helpers/assign"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// initializes binsing between a property of an object to HTML node
function bindNode(object, key, node, binder, eventOptions) {
  if ((0, _typeof2["default"])(this) === 'object' && this.isSeemple) {
    // when context is Seemple instance, use this as an object and shift other args

    /* eslint-disable no-param-reassign */
    eventOptions = binder;
    binder = node;
    node = key;
    key = object;
    object = this;
    /* eslint-enable no-param-reassign */
  } else {
    // throw error when object type is wrong
    (0, _checkobjecttype["default"])(object, 'bindNode');
  }

  eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign

  binder = binder || {}; // eslint-disable-line no-param-reassign

  (0, _init["default"])(object);
  var temporaryOptionalFlag = bindNode.temporaryOptionalFlag;
  delete bindNode.temporaryOptionalFlag; // throw an error when key is falsy

  if (!key) {
    throw (0, _seempleerror["default"])('binding:falsy_key');
  }

  if (key instanceof Array) {
    if (typeof key[0] === 'string') {
      /*
             * accept array of keys
             * this.bindNode(['a', 'b', 'c'], node)
             */
      if (temporaryOptionalFlag) {
        // eslint-disable-next-line no-param-reassign
        eventOptions = _objectSpread({}, eventOptions, {
          optional: true
        });
      }

      (0, _foreach["default"])(key, function (itemKey) {
        return bindNode(object, itemKey, node, binder, eventOptions);
      });
    } else {
      /*
             * accept array of objects
             * this.bindNode([{key, node, binder, event}], { silent: true });
             */
      (0, _foreach["default"])(key, function (_ref) {
        var itemKey = _ref.key,
            itemNode = _ref.node,
            itemBinder = _ref.binder,
            itemEventOptions = _ref.event;
        var commonEventOptions = node;
        var mergedEventOptions = {};

        if (temporaryOptionalFlag) {
          mergedEventOptions.optional = true;
        }

        if (commonEventOptions) {
          // extend event object by "global" event
          (0, _assign["default"])(mergedEventOptions, commonEventOptions);
        }

        if (itemEventOptions) {
          // extend event object by "local" event ("event" key of an object)
          (0, _assign["default"])(mergedEventOptions, itemEventOptions);
        }

        bindNode(object, itemKey, itemNode, itemBinder, mergedEventOptions);
      });
    }

    return object;
  }

  if ((0, _typeof2["default"])(key) === 'object') {
    (0, _forown["default"])(key, function (keyObjValue, keyObjKey) {
      // binder means eventOptions
      if (temporaryOptionalFlag) {
        // eslint-disable-next-line no-param-reassign
        eventOptions = binder ? _objectSpread({}, binder, {
          optional: true
        }) : {
          optional: true
        };
      } else {
        eventOptions = binder; // eslint-disable-line no-param-reassign
      }

      if (keyObjValue && keyObjValue.constructor === Object && 'node' in keyObjValue) {
        // this.bindNode({ key: { node: $(), binder } ) }, { on: 'evt' }, { silent: true });
        bindNode(object, keyObjKey, keyObjValue.node, keyObjValue.binder || node, eventOptions);
      } else if (keyObjValue && keyObjValue.constructor === Array && keyObjValue.length && keyObjValue[0].constructor === Object && 'node' in keyObjValue[0]) {
        // this.bindNode({ key: [{
        //   node: $(),
        //   binder
        // }] ) }, { on: 'evt' }, { silent: true });
        (0, _foreach["default"])(keyObjValue, function (keyObjValueItem) {
          bindNode(object, keyObjKey, keyObjValueItem.node, keyObjValueItem.binder || node, eventOptions);
        });
      } else {
        // this.bindNode({ key: $() }, { on: 'evt' }, { silent: true });
        bindNode(object, keyObjKey, keyObjValue, node, eventOptions);
      }
    });
    return object;
  }

  var _eventOptions = eventOptions,
      _eventOptions$optiona = _eventOptions.optional,
      optional = _eventOptions$optiona === void 0 ? temporaryOptionalFlag || false : _eventOptions$optiona,
      _eventOptions$exactKe = _eventOptions.exactKey,
      exactKey = _eventOptions$exactKe === void 0 ? false : _eventOptions$exactKe;
  var $nodes = (0, _getnodes["default"])(object, node); // check node existence

  if (!$nodes.length) {
    if (optional) {
      return object;
    }

    throw (0, _seempleerror["default"])('binding:node_missing', {
      key: key,
      node: node
    });
  }

  if (!exactKey) {
    var deepPath = key.split('.');
    var deepPathLength = deepPath.length;

    if (deepPathLength > 1) {
      // handle binding when key arg includes dots (eg "a.b.c.d")
      var bindingSwitcher = (0, _createbindingswitcher["default"])({
        object: object,
        deepPath: deepPath,
        $nodes: $nodes,
        binder: binder,
        eventOptions: eventOptions,
        bindNode: bindNode
      });
      (0, _addtreelistener["default"])(object, deepPath.slice(0, deepPathLength - 1), bindingSwitcher);
      bindingSwitcher();
      return object;
    }
  }

  var propDef = (0, _defineprop["default"])(object, key);

  if (object.isSeemple) {
    // if an object is Seemple instance then extend "$nodes" and "nodes" objects
    var _object = object,
        $allNodes = _object.$nodes,
        allNodes = _object.nodes;

    if (!$allNodes || !allNodes) {
      throw (0, _seempleerror["default"])('binding:instance_nodes_missing', {
        $nodes: $allNodes,
        nodes: allNodes
      });
    }

    $allNodes[key] = $allNodes[key] && $allNodes[key].length ? $allNodes[key].add($nodes) : $nodes;
    allNodes[key] = $allNodes[key][0];
  } // handle binding for every node separately


  (0, _foreach["default"])($nodes, function (oneNode) {
    return (0, _bindsinglenode["default"])(object, {
      $nodes: $nodes,
      node: oneNode,
      key: key,
      eventOptions: eventOptions,
      binder: binder,
      propDef: propDef
    });
  });
  return object;
}
//# sourceMappingURL=index.js.map