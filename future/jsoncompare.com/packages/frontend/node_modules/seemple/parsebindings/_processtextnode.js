"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = processTextNode;

var _parserdata = _interopRequireDefault(require("./_parserdata"));

var _bindnode = _interopRequireDefault(require("../bindnode"));

var _foreach = _interopRequireDefault(require("../_helpers/foreach"));

var textNodeBinder = {
  setValue: function setValue(value) {
    this.textContent = typeof value === 'undefined' ? '' : value;
  }
}; // adds binding for text node
// it splits up one text node into "simple text nodes"
// and "bound text nodes" and removes original text node

function processTextNode(_ref) {
  var object = _ref.object,
      node = _ref.node,
      textNode = _ref.textNode,
      eventOptions = _ref.eventOptions;
  var bindingReg = _parserdata["default"].bindingReg;
  var textContent = textNode.textContent;
  var _window = window,
      document = _window.document;
  bindingReg.lastIndex = 0; // tokens variable contains normal text as odd items
  // and bound keys as even items
  // 'foo{{x}}bar{{y}}baz{{z}}' -> ['foo', 'x', 'bar', 'y', 'baz', 'z', '']

  var tokens = textContent.split(bindingReg); // fragment contains all new text nodes

  var fragment = document.createDocumentFragment();
  (0, _foreach["default"])(tokens, function (token, index) {
    if (token) {
      var newTextNode = document.createTextNode(token);
      fragment.appendChild(newTextNode); // if tokens item is even then it is a key
      // which needs to be bound to newly created text node

      if (index % 2 !== 0) {
        (0, _bindnode["default"])(object, token, newTextNode, textNodeBinder, eventOptions);
      }
    }
  });
  node.insertBefore(fragment, textNode);
  node.removeChild(textNode);
}
//# sourceMappingURL=_processtextnode.js.map