{"version":3,"sources":["../../src/parsebindings/_processtextnode.js"],"names":["textNodeBinder","setValue","value","textContent","processTextNode","object","node","textNode","eventOptions","bindingReg","parserData","window","document","lastIndex","tokens","split","fragment","createDocumentFragment","token","index","newTextNode","createTextNode","appendChild","insertBefore","removeChild"],"mappings":";;;;;;;;;AAAA;;AACA;;AACA;;AAGA,IAAMA,cAAc,GAAG;AACrBC,EAAAA,QADqB,oBACZC,KADY,EACL;AACd,SAAKC,WAAL,GAAmB,OAAOD,KAAP,KAAiB,WAAjB,GAA+B,EAA/B,GAAoCA,KAAvD;AACD;AAHoB,CAAvB,C,CAMA;AACA;AACA;;AACe,SAASE,eAAT,OAKZ;AAAA,MAJDC,MAIC,QAJDA,MAIC;AAAA,MAHDC,IAGC,QAHDA,IAGC;AAAA,MAFDC,QAEC,QAFDA,QAEC;AAAA,MADDC,YACC,QADDA,YACC;AAAA,MACOC,UADP,GACsBC,sBADtB,CACOD,UADP;AAAA,MAEON,WAFP,GAEuBI,QAFvB,CAEOJ,WAFP;AAAA,gBAGoBQ,MAHpB;AAAA,MAGOC,QAHP,WAGOA,QAHP;AAKDH,EAAAA,UAAU,CAACI,SAAX,GAAuB,CAAvB,CALC,CAOD;AACA;AACA;;AACA,MAAMC,MAAM,GAAGX,WAAW,CAACY,KAAZ,CAAkBN,UAAlB,CAAf,CAVC,CAYD;;AACA,MAAMO,QAAQ,GAAGJ,QAAQ,CAACK,sBAAT,EAAjB;AAEA,2BAAQH,MAAR,EAAgB,UAACI,KAAD,EAAQC,KAAR,EAAkB;AAChC,QAAID,KAAJ,EAAW;AACT,UAAME,WAAW,GAAGR,QAAQ,CAACS,cAAT,CAAwBH,KAAxB,CAApB;AACAF,MAAAA,QAAQ,CAACM,WAAT,CAAqBF,WAArB,EAFS,CAIT;AACA;;AACA,UAAID,KAAK,GAAG,CAAR,KAAc,CAAlB,EAAqB;AACnB,kCAASd,MAAT,EAAiBa,KAAjB,EAAwBE,WAAxB,EAAqCpB,cAArC,EAAqDQ,YAArD;AACD;AACF;AACF,GAXD;AAaAF,EAAAA,IAAI,CAACiB,YAAL,CAAkBP,QAAlB,EAA4BT,QAA5B;AACAD,EAAAA,IAAI,CAACkB,WAAL,CAAiBjB,QAAjB;AACD","sourcesContent":["import parserData from './_parserdata';\nimport bindNode from '../bindnode';\nimport forEach from '../_helpers/foreach';\n\n\nconst textNodeBinder = {\n  setValue(value) {\n    this.textContent = typeof value === 'undefined' ? '' : value;\n  }\n};\n\n// adds binding for text node\n// it splits up one text node into \"simple text nodes\"\n// and \"bound text nodes\" and removes original text node\nexport default function processTextNode({\n  object,\n  node,\n  textNode,\n  eventOptions\n}) {\n  const { bindingReg } = parserData;\n  const { textContent } = textNode;\n  const { document } = window;\n\n  bindingReg.lastIndex = 0;\n\n  // tokens variable contains normal text as odd items\n  // and bound keys as even items\n  // 'foo{{x}}bar{{y}}baz{{z}}' -> ['foo', 'x', 'bar', 'y', 'baz', 'z', '']\n  const tokens = textContent.split(bindingReg);\n\n  // fragment contains all new text nodes\n  const fragment = document.createDocumentFragment();\n\n  forEach(tokens, (token, index) => {\n    if (token) {\n      const newTextNode = document.createTextNode(token);\n      fragment.appendChild(newTextNode);\n\n      // if tokens item is even then it is a key\n      // which needs to be bound to newly created text node\n      if (index % 2 !== 0) {\n        bindNode(object, token, newTextNode, textNodeBinder, eventOptions);\n      }\n    }\n  });\n\n  node.insertBefore(fragment, textNode);\n  node.removeChild(textNode);\n}\n"],"file":"_processtextnode.js"}