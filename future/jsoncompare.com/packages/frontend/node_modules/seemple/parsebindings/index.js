"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = parseBindings;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _checkobjecttype = _interopRequireDefault(require("../_helpers/checkobjecttype"));

var _dom = _interopRequireDefault(require("../_dom"));

var _parserdata = _interopRequireDefault(require("./_parserdata"));

var _processtextnode = _interopRequireDefault(require("./_processtextnode"));

var _processattribute = _interopRequireDefault(require("./_processattribute"));

var _getnodes = _interopRequireDefault(require("../bindnode/_getnodes"));

var _foreach = _interopRequireDefault(require("../_helpers/foreach"));

var _assign = _interopRequireDefault(require("../_helpers/assign"));

// makes parsing of given node (node, $(nodes), selector, HTML)
// and initializes bindings for attributes and text nodes which contain things like {{foo}}
function parseBindings(object, givenNodes, eventOptions) {
  if ((0, _typeof2["default"])(this) === 'object' && this.isSeemple) {
    // when context is Seemple instance, use this as an object and shift other args

    /* eslint-disable no-param-reassign */
    eventOptions = givenNodes;
    givenNodes = object;
    object = this;
    /* eslint-enable no-param-reassign */
  } else {
    // throw error when object type is wrong
    (0, _checkobjecttype["default"])(object, 'parseBindings');
  }

  var extendedEventOptions = {
    // useExactBinder is little optimization
    // without this option used binder is extended by default binder
    useExactBinder: true,
    fromParser: true,
    setValueOnBind: true
  };

  if ((0, _typeof2["default"])(eventOptions) === 'object') {
    (0, _assign["default"])(extendedEventOptions, eventOptions);
  }

  var nodes;
  var allNodes = []; // extract all needed data from parserData
  // check out what is parserData in its module

  var leftBracket = _parserdata["default"].leftBracket,
      bindingReg = _parserdata["default"].bindingReg;

  if (typeof givenNodes === 'string') {
    if (~givenNodes.indexOf('<')) {
      // this is HTML
      nodes = _dom["default"].$.parseHTML(givenNodes);

      if (!~givenNodes.indexOf(leftBracket)) {
        // if it doesn't include parser bracket then we don't need to check
        // their existence for all included nodes in cycle below
        return nodes;
      }
    } else {
      // this is a selector
      nodes = (0, _getnodes["default"])(object, givenNodes);
    }
  } else if ((0, _typeof2["default"])(givenNodes) === 'object') {
    // this is a node, nodeList or something else (eg array, jQuery instance etc)
    nodes = _dom["default"].$(givenNodes);
  } // to make possible to not use recursion we're collecting all nodes to allNodes array


  (0, _foreach["default"])(nodes, function (node) {
    return allNodes.push(node);
  }); // on every cycle of array we're adding new descendants to allNodes
  // increasing # of needed iterations

  var _loop = function _loop(i) {
    var node = allNodes[i];
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3; // allow to parse elements only

    if (node.nodeType !== ELEMENT_NODE) {
      return "continue";
    }

    var outerHTML = node.outerHTML,
        innerHTML = node.innerHTML,
        childNodes = node.childNodes,
        attributes = node.attributes; // if outerHTML does't contain left bracket, then this node doesn't need to be parsed
    // we may need to check outerHTML existence for older browsers
    // we may need to add !~outerHTML.indexOf(encodeURI(leftBracket) to support old FF

    if (!~outerHTML.indexOf(leftBracket)) {
      return "continue";
    } // initialize bindings for attributes if they appear


    if (attributes.length) {
      // fixes Firefox issue: attributes.length can be changed by processAttribute
      var attrs = attributes.length > 1 ? Array.prototype.slice.call(attributes) : attributes;
      (0, _foreach["default"])(attrs, function (attribute) {
        if (bindingReg.test(attribute.value)) {
          (0, _processattribute["default"])({
            node: node,
            attribute: attribute,
            object: object,
            eventOptions: extendedEventOptions
          });
        }
      });
    } // if innerHTML does't contain left bracket,
    // then children of this node don't need to be parsed
    // we may need to add !~innerHTML.indexOf(encodeURI(leftBracket) to support old FF


    if (!~innerHTML.indexOf(leftBracket)) {
      return "continue";
    }

    for (var j = 0; j < childNodes.length; j++) {
      var childNode = childNodes[j];
      var nodeType = childNode.nodeType,
          textContent = childNode.textContent;

      if (nodeType === ELEMENT_NODE) {
        // if childNode is HTML element then add it to the end of allNodes array
        // to check everything on next outer cycle iterations
        allNodes.push(childNode);
      } else if (nodeType === TEXT_NODE) {
        // if childNode is text node which contains things like {{x}}
        // then initialize bindings for this node
        if (bindingReg.test(textContent)) {
          (0, _processtextnode["default"])({
            object: object,
            node: node,
            textNode: childNode,
            eventOptions: extendedEventOptions
          });
        }
      }
    }
  };

  for (var i = 0; i < allNodes.length; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }

  return nodes;
}
//# sourceMappingURL=index.js.map