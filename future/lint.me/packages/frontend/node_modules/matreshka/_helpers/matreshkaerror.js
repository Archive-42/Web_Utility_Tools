'use strict';

/* eslint-disable prefer-template, max-len */
var bindingErrorPrefix = 'Binding error:';
var calcErrorPrefix = 'Calc error:';
var eventsErrorPrefix = 'Events error:';
var arrayErrorPrefix = 'Matreshka.Array error:';

var getType = function (variable) {
    if (variable === null) {
        return 'null';
    }

    return typeof variable;
};
var getTypeError = function (variable, variableName, expectedType) {
    return variableName + ' must have type "' + expectedType + '" but got "' + getType(variable) + '" instead.';
};

var errors = {
    'common:object_type': function (_ref) {
        var object = _ref.object,
            method = _ref.method;
        return 'Error in ' + method + ': ' + getTypeError(object, 'object', 'object');
    },
    'common:call_class': function () {
        return 'Cannot call a class as a function';
    },
    'common:use_magic_props': function () {
        return '"sandbox" key (for all objects) and "container" key (for Matreshka.Array instances)' + ' are reserved for service use and cannot be used as usual properties';
    },

    'binding:node_missing': function (_ref2) {
        var key = _ref2.key,
            node = _ref2.node;

        var selectorInfo = typeof node === 'string' ? ' (given selector is "' + node + '")' : '';
        return bindingErrorPrefix + ' node is missing for key "' + key + '"' + selectorInfo + '.';
    },
    'binding:falsy_key': function () {
        return bindingErrorPrefix + ' "key" arg cannot be falsy';
    },
    'binding:instance_nodes_missing': function (_ref3) {
        var $nodes = _ref3.$nodes;

        var missing = !$nodes ? '$nodes' : 'nodes';
        return bindingErrorPrefix + ' "' + missing + '" property of Matreshka instance is missing.' + ' It must be an object and must not be reassigned.';
    },
    'binding:magic_props_nodes_length': function () {
        return bindingErrorPrefix + ' "sandbox" key (for all objects) and "container" key' + ' (for Matreshka.Array instances) cannot have more than one bound node';
    },

    'calc:target_type': function (_ref4) {
        var target = _ref4.target;
        return calcErrorPrefix + ' ' + getTypeError(target, 'target key', 'string');
    },
    'calc:source_key_type': function (_ref5) {
        var sourceKey = _ref5.sourceKey;
        return calcErrorPrefix + ' ' + getTypeError(sourceKey, 'source key', 'string');
    },
    'calc:source_object_type': function (_ref6) {
        var sourceObject = _ref6.sourceObject;
        return calcErrorPrefix + ' ' + getTypeError(sourceObject, 'source object', 'object');
    },
    'calc:source_type': function (_ref7) {
        var source = _ref7.source;
        return calcErrorPrefix + ' ' + getTypeError(source, 'source', 'object');
    },

    'array:model_type': function (_ref8) {
        var Model = _ref8.Model;
        return arrayErrorPrefix + ' ' + getTypeError(Model, 'Model', 'function');
    },
    'array:add_render_twice': function () {
        return arrayErrorPrefix + ' one rendered object was inserted twice.';
    },
    'array:rendered_number_nodes': function (_ref9) {
        var length = _ref9.length;
        return arrayErrorPrefix + ' renderer returned ' + length + ' nodes instead of one.' + (' ' + (length > 0 ? 'To fix this wrap these nodes by single node.' : ''));
    },
    'array:renderer_node_missing': function (_ref10) {
        var selector = _ref10.selector;
        return arrayErrorPrefix + ' renderer node is missing (given selector is "' + selector + '")';
    },
    'array:nonexistent_method': function (_ref11) {
        var method = _ref11.method;
        return arrayErrorPrefix + ' Array.prototype.' + method + ' doesn\'t exist.' + ' You need to include a polyfill for it (e. g. babel-node)';
    },
    'array:method_compat_renderer': function (_ref12) {
        var method = _ref12.method;
        return arrayErrorPrefix + ' Not possible to render when ' + method + ' method is called';
    },

    'pull:to_remove_type': function (_ref13) {
        var toRemove = _ref13.toRemove;
        return 'Error in pull: ' + getTypeError(toRemove, 'toRemove', 'number');
    },

    'restore:no_nodes': function () {
        return arrayErrorPrefix + ' cannot find any container to restore an instance using "restore" method';
    },

    'trigger:names_type': function (_ref14) {
        var names = _ref14.names;
        return eventsErrorPrefix + ' ' + getTypeError(names, 'event name', 'string');
    },

    'on:names_type': function (_ref15) {
        var names = _ref15.names;
        return errors['trigger:names_type']({ names: names });
    },

    'removedatakeys:key_type': function (_ref16) {
        var key = _ref16.key;
        return 'Error in removeDataKeys: ' + getTypeError(key, 'key', 'string');
    },

    'adddatakeys:key_type': function (_ref17) {
        var key = _ref17.key;
        return 'Error in addDataKeys: ' + getTypeError(key, 'key', 'string');
    },

    'remove:key_type': function (_ref18) {
        var key = _ref18.key;
        return 'Error in remove: ' + getTypeError(key, 'key', 'string');
    },

    'mediate:key_type': function (_ref19) {
        var key = _ref19.key;
        return 'Error in mediate: ' + getTypeError(key, 'key', 'string');
    }
};

module.exports = matreshkaError;
function matreshkaError(key, data) {
    var getError = errors[key];
    if (!getError) {
        throw Error('Unknown error "' + key + '". Please report about this on Github.');
    }

    return new Error(getError(data));
}
//# sourceMappingURL=matreshkaerror.js.map