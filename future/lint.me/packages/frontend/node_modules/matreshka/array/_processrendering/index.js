'use strict';

var defs = require('../../_core/defs');

var matreshkaError = require('../../_helpers/matreshkaerror');

var processPush = require('./processpush');

var processUnshift = require('./processunshift');

var processRecreate = require('./processrecreate');

var processSort = require('./processsort');

var processRemove = require('./processremove');

var processRerender = require('./processrerender');

var processSpliceAdd = require('./processspliceadd');

// makes possible to render array items based on a name of called method
module.exports = processRendering;
function processRendering(_ref) {
    var self = _ref.self,
        eventOptions = _ref.eventOptions;
    var method = eventOptions.method,
        added = eventOptions.added,
        removed = eventOptions.removed;
    // nodes object always exist at Matreshka instances

    var container = self.nodes.container || self.nodes.sandbox;
    var selfDef = defs.get(self);

    if (!container) {
        return;
    }

    switch (method) {
        case 'fill':
        case 'copyWithin':
            throw matreshkaError('array:method_compat_renderer', { method: method });
        case 'push':
            processPush({
                self: self,
                selfDef: selfDef,
                eventOptions: eventOptions,
                container: container
            });
            break;
        case 'unshift':
            processUnshift({
                self: self,
                selfDef: selfDef,
                eventOptions: eventOptions,
                container: container
            });
            break;
        case 'pull':
        case 'pop':
        case 'shift':
            processRemove({
                self: self,
                selfDef: selfDef,
                eventOptions: eventOptions,
                container: container
            });
            break;
        case 'sort':
        case 'reverse':
            processSort({
                self: self,
                selfDef: selfDef,
                eventOptions: eventOptions,
                container: container
            });
            break;
        case 'rerender':
            processRerender({
                self: self,
                selfDef: selfDef,
                eventOptions: eventOptions,
                container: container
            });
            break;
        case 'recreate':
            processRecreate({
                self: self,
                selfDef: selfDef,
                eventOptions: eventOptions,
                container: container
            });
            break;
        case 'splice':
            if (added.length) {
                processSpliceAdd({
                    self: self,
                    selfDef: selfDef,
                    eventOptions: eventOptions,
                    container: container
                });
            }

            if (removed.length) {
                processRemove({
                    self: self,
                    selfDef: selfDef,
                    eventOptions: eventOptions,
                    container: container
                });
            }

            break;
        default:
            return;
    }
}
//# sourceMappingURL=index.js.map