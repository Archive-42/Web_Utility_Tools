{"version":3,"sources":["../../../src/array/_processrendering/processrecreate.js"],"names":["processRecreate","self","selfDef","eventOptions","container","removed","silent","selfId","id","item","itemDef","defs","get","renderedInArrays","node","removeChild","alreadyRenderedMap","alreadyRenderedNode","getAlreadyRendered","matreshkaError","appendChild","renderItemNode","itemEventOptions","triggerOne"],"mappings":";;6BAA2B,kB;;yBACJ,2B;;mBACN,kB;;6BACU,+B;;iCACI,sB;;AAE/B;iBACwBA,e;AAAT,SAASA,eAAT,OAKZ;AAAA,QAJCC,IAID,QAJCA,IAID;AAAA,QAHCC,OAGD,QAHCA,OAGD;AAAA,QAFCC,YAED,QAFCA,YAED;AAAA,QADCC,SACD,QADCA,SACD;AAAA,QACSC,OADT,GAC6BF,YAD7B,CACSE,OADT;AAAA,QACkBC,MADlB,GAC6BH,YAD7B,CACkBG,MADlB;AAAA,QAEaC,MAFb,GAEwBL,OAFxB,CAESM,EAFT;;AAIC;;AAJD,uBAKcH,OALd,cAKwBI,IALxB,uBAKwBA,IALxB,2CAKiC;AAC5B,YAAMC,UAAUC,KAAKC,GAAL,CAASH,IAAT,CAAhB;;AAEA,YAAIC,OAAJ,EAAa;AAAA,gBACDG,gBADC,GACoBH,OADpB,CACDG,gBADC;;AAET,gBAAMC,OAAOD,oBAAoBA,iBAAiBN,MAAjB,CAAjC;AACA,gBAAIO,IAAJ,EAAU;AACN,uBAAOJ,QAAQG,gBAAR,CAAyBN,MAAzB,CAAP;AACAH,0BAAUW,WAAV,CAAsBD,IAAtB;AACH;AACJ;AACJ;;AAED,QAAME,qBAAqB,EAA3B;;AAEA;AACA;AACA;;AAtBD,wBAuBcf,IAvBd,eAuBqBQ,IAvBrB,yBAuBqBA,IAvBrB,gDAuB8B;AACzB,YAAIA,QAAQ,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AAClC,gBAAIC,UAAUC,KAAKC,GAAL,CAASH,IAAT,CAAd;AACA,gBAAIQ,4BAAJ;;AAEA,gBAAIP,OAAJ,EAAa;AACTO,sCAAsBC,mBAAmB;AACrCT,8BADqC;AAErCP;AAFqC,iBAAnB,CAAtB;AAIH;;AAED,gBAAIe,mBAAJ,EAAyB;AACrB;AACA,oBAAIP,QAAQF,EAAR,IAAcQ,kBAAlB,EAAsC;AAClC;AACA,0BAAMG,eAAe,wBAAf,CAAN;AACH;;AAEDH,mCAAmBN,QAAQF,EAA3B,IAAiC,IAAjC;;AAEAJ,0BAAUgB,WAAV,CAAsBH,mBAAtB;AACH,aAVD,MAUO;AACH;AADG,sCAEgCI,eAAe;AAC9CnB,oCAD8C;AAE9CD,8BAF8C;AAG9CQ,8BAH8C;AAI9CN;AAJ8C,iBAAf,CAFhC;AAAA,oBAEKW,IAFL,mBAEKA,IAFL;AAAA,oBAEWQ,gBAFX,mBAEWA,gBAFX;;AASH,oBAAIR,IAAJ,EAAU;AACN;AACA;AACAJ,8BAAUA,WAAWC,KAAKC,GAAL,CAASH,IAAT,CAArB;;AAEA,wBAAIC,QAAQF,EAAR,IAAcQ,kBAAlB,EAAsC;AAClC;AACA,8BAAMG,eAAe,wBAAf,CAAN;AACH;;AAEDH,uCAAmBN,QAAQF,EAA3B,IAAiC,IAAjC;;AAEAJ,8BAAUgB,WAAV,CAAsBN,IAAtB;;AAEA,wBAAI,CAACR,MAAL,EAAa;AACTiB,mCAAWd,IAAX,EAAiB,aAAjB,EAAgCa,gBAAhC;AACH;AACJ;AACJ;AACJ;AACJ;AACJ","file":"processrecreate.js","sourcesContent":["import renderItemNode from './renderitemnode';\nimport triggerOne from '../../trigger/_triggerone';\nimport defs from '../../_core/defs';\nimport matreshkaError from '../../_helpers/matreshkaerror';\nimport getAlreadyRendered from './getalreadyrendered';\n\n// this function renders inserted items if possible when recreate method is called\nexport default function processRecreate({\n    self,\n    selfDef,\n    eventOptions,\n    container\n}) {\n    const { removed, silent } = eventOptions;\n    const { id: selfId } = selfDef;\n\n    // iterate over removed items and remove their nodes\n    nofn.forEach(removed, (item) => {\n        const itemDef = defs.get(item);\n\n        if (itemDef) {\n            const { renderedInArrays } = itemDef;\n            const node = renderedInArrays && renderedInArrays[selfId];\n            if (node) {\n                delete itemDef.renderedInArrays[selfId];\n                container.removeChild(node);\n            }\n        }\n    });\n\n    const alreadyRenderedMap = {};\n\n    // iterate over all items\n    // the following approach allows to throw an error when two added objects are the same\n    // (not only compare existing items with old ones)\n    nofn.forEach(self, (item) => {\n        if (item && typeof item === 'object') {\n            let itemDef = defs.get(item);\n            let alreadyRenderedNode;\n\n            if (itemDef) {\n                alreadyRenderedNode = getAlreadyRendered({\n                    item,\n                    selfDef\n                });\n            }\n\n            if (alreadyRenderedNode) {\n                // if an item is already rendered (old item)\n                if (itemDef.id in alreadyRenderedMap) {\n                    // if an item is rendered twice throw an error\n                    throw matreshkaError('array:add_render_twice');\n                }\n\n                alreadyRenderedMap[itemDef.id] = true;\n\n                container.appendChild(alreadyRenderedNode);\n            } else {\n                // this is newly added item\n                const { node, itemEventOptions } = renderItemNode({\n                    selfDef,\n                    self,\n                    item,\n                    eventOptions\n                });\n\n                if (node) {\n                    // itemDef is defined at renderItemNode if not defined before\n                    // reload this variable\n                    itemDef = itemDef || defs.get(item);\n\n                    if (itemDef.id in alreadyRenderedMap) {\n                        // if newly added item is rendered twice throw an error\n                        throw matreshkaError('array:add_render_twice');\n                    }\n\n                    alreadyRenderedMap[itemDef.id] = true;\n\n                    container.appendChild(node);\n\n                    if (!silent) {\n                        triggerOne(item, 'afterrender', itemEventOptions);\n                    }\n                }\n            }\n        }\n    });\n}\n"]}