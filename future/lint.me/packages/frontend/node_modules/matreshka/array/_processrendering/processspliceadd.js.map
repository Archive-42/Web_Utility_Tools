{"version":3,"sources":["../../../src/array/_processrendering/processspliceadd.js"],"names":["processSpliceAdd","self","selfDef","eventOptions","container","added","silent","nextIndex","lastIndexOf","length","next","nextNode","getAlreadyRendered","item","checkAlreadyRendered","renderItemNode","node","itemEventOptions","insertBefore","appendChild","triggerOne"],"mappings":";;6BAA2B,kB;;yBACJ,2B;;mCACU,wB;;iCACF,sB;;AAE/B;iBACwBA,gB;AAAT,SAASA,gBAAT,OAKZ;AAAA,QAJCC,IAID,QAJCA,IAID;AAAA,QAHCC,OAGD,QAHCA,OAGD;AAAA,QAFCC,YAED,QAFCA,YAED;AAAA,QADCC,SACD,QADCA,SACD;AAAA,QACSC,KADT,GAC2BF,YAD3B,CACSE,KADT;AAAA,QACgBC,MADhB,GAC2BH,YAD3B,CACgBG,MADhB;;AAEC,QAAMC,YAAYN,KAAKO,WAAL,CAAiBH,MAAMA,MAAMI,MAAN,GAAe,CAArB,CAAjB,IAA4C,CAA9D;AACA,QAAMC,OAAOT,KAAKM,SAAL,CAAb;AACA,QAAII,iBAAJ;;AAEA;AACA;AACA,QAAID,QAAQ,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AAClCC,mBAAWC,mBAAmB;AAC1BC,kBAAMH,IADoB;AAE1BR;AAF0B,SAAnB,CAAX;AAIH;;AAbF,uBAecG,KAfd,cAesBQ,IAftB,uBAesBA,IAftB,2CAe+B;AAC1B,YAAIA,QAAQ,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AAClC;AACAC,iCAAqB;AACjBD,0BADiB;AAEjBX;AAFiB,aAArB;;AAFkC,kCAOCa,eAAe;AAC9Cb,gCAD8C;AAE9CD,0BAF8C;AAG9CY,0BAH8C;AAI9CV;AAJ8C,aAAf,CAPD;AAAA,gBAO1Ba,IAP0B,mBAO1BA,IAP0B;AAAA,gBAOpBC,gBAPoB,mBAOpBA,gBAPoB;;AAclC,gBAAID,IAAJ,EAAU;AACN,oBAAIL,QAAJ,EAAc;AACVP,8BAAUc,YAAV,CAAuBF,IAAvB,EAA6BL,QAA7B;AACH,iBAFD,MAEO;AACHP,8BAAUe,WAAV,CAAsBH,IAAtB;AACH;;AAED,oBAAI,CAACV,MAAL,EAAa;AACTc,+BAAWP,IAAX,EAAiB,aAAjB,EAAgCI,gBAAhC;AACH;AACJ;AACJ;AACJ;AACJ","file":"processspliceadd.js","sourcesContent":["import renderItemNode from './renderitemnode';\nimport triggerOne from '../../trigger/_triggerone';\nimport checkAlreadyRendered from './checkalreadyrendered';\nimport getAlreadyRendered from './getalreadyrendered';\n\n// the function handles rendering of added items passed as third and rest arguments to splice method\nexport default function processSpliceAdd({\n    self,\n    selfDef,\n    eventOptions,\n    container\n}) {\n    const { added, silent } = eventOptions;\n    const nextIndex = self.lastIndexOf(added[added.length - 1]) + 1;\n    const next = self[nextIndex];\n    let nextNode;\n\n    // get a node of an item which is placed next to the last added item\n    // it is needed to insert newly rendered items before\n    if (next && typeof next === 'object') {\n        nextNode = getAlreadyRendered({\n            item: next,\n            selfDef\n        });\n    }\n\n    nofn.forEach(added, (item) => {\n        if (item && typeof item === 'object') {\n            // throw an error if node of an item is alread rendered\n            checkAlreadyRendered({\n                item,\n                selfDef\n            });\n\n            const { node, itemEventOptions } = renderItemNode({\n                selfDef,\n                self,\n                item,\n                eventOptions\n            });\n\n            if (node) {\n                if (nextNode) {\n                    container.insertBefore(node, nextNode);\n                } else {\n                    container.appendChild(node);\n                }\n\n                if (!silent) {\n                    triggerOne(item, 'afterrender', itemEventOptions);\n                }\n            }\n        }\n    });\n}\n"]}