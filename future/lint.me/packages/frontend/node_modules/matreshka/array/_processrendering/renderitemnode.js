'use strict';

var parseBindings = require('../../parsebindings');

var bindNode = require('../../bindnode');

var unbindNode = require('../../unbindnode');

var triggerOne = require('../../trigger/_triggerone');

var initMK = require('../../_core/init');

var matreshkaError = require('../../_helpers/matreshkaerror');

var getNodes = require('../../bindnode/_getnodes');

var htmlTestReg = /</;

// the function makes the main rendering job
// it renders given array item
module.exports = renderItemNode;
function renderItemNode(_ref) {
    var selfDef = _ref.selfDef,
        self = _ref.self,
        item = _ref.item,
        eventOptions = _ref.eventOptions;
    var renderer = item.renderer,
        _item$bindRenderedAsS = item.bindRenderedAsSandbox,
        bindRenderedAsSandbox = _item$bindRenderedAsS === undefined ? true : _item$bindRenderedAsS;
    var itemRenderer = self.itemRenderer;

    var usedRenderer = renderer || itemRenderer;
    var rendererContext = usedRenderer === renderer ? item : self;
    var selfId = selfDef.id;
    var moveSandbox = eventOptions.moveSandbox,
        forceRerender = eventOptions.forceRerender,
        silent = eventOptions.silent;

    // if renderer is not found return null as a node

    if (!usedRenderer) {
        return { node: null };
    }

    var itemDef = initMK(item);
    var _itemDef$renderedInAr = itemDef.renderedInArrays,
        renderedInArrays = _itemDef$renderedInAr === undefined ? {} : _itemDef$renderedInAr;

    // if moveSandbox option is truthy then return a sandbox of an item

    if (moveSandbox) {
        var sandboxPropDef = itemDef.props.sandbox;
        if (sandboxPropDef) {
            var bindings = sandboxPropDef.bindings;

            var _node = bindings ? bindings[0].node : null;

            if (_node) {
                for (var i = 0, keys = Object.keys(renderedInArrays); i < keys.length; i++) {
                    var key = keys[i];

                    if (_node === renderedInArrays[key]) {
                        // delete an information about previous array
                        delete renderedInArrays[key];
                        break;
                    }
                }

                renderedInArrays[selfId] = _node;

                // moving sandbox does not fire "render" event but it fire "afterrender"
                // since "afterrender" means "node is inserted to DOM"
                return {
                    node: _node,
                    itemEventOptions: {
                        node: _node,
                        self: item,
                        parentArray: self
                    }
                };
            }
        }
    }

    itemDef.renderedInArrays = renderedInArrays;

    // if usedRenderer is function then call it
    if (typeof usedRenderer === 'function') {
        usedRenderer = usedRenderer.call(rendererContext, item);
    }

    // if usedRenderer is string
    if (typeof usedRenderer === 'string') {
        if (!htmlTestReg.test(usedRenderer)) {
            // if usedRenderer is a selector
            var selector = usedRenderer;

            usedRenderer = getNodes(self, selector);

            if (usedRenderer.length) {
                // if a node is found by given selector then use its HTML
                usedRenderer = usedRenderer[0].innerHTML.trim();
            } else {
                // if not throw an error
                throw matreshkaError('array:renderer_node_missing', { selector: selector });
            }
        } else {
            // if usedRenderer is HTML string
            usedRenderer = usedRenderer.trim();
        }
    }

    // pass a node or HTML
    var parsed = parseBindings(item, usedRenderer, eventOptions);

    // if parseBindings returned more/less than one node then throw an error
    if (parsed.length !== 1) {
        throw matreshkaError('array:rendered_number_nodes', { length: parsed.length });
    }

    var node = renderedInArrays[selfId] = parsed[0];

    if (bindRenderedAsSandbox) {
        if (forceRerender) {
            unbindNode(item, 'sandbox', null, null, eventOptions);
        }

        bindNode(item, 'sandbox', node, null, eventOptions);
    }

    // if silent is not truthy then fire 'render' event and virtual methods
    if (!silent) {
        var itemEventOptions = {
            node: node,
            self: item,
            parentArray: self
        };
        var onRender = item.onRender;
        var onItemRender = self.onItemRender;


        if (onRender) {
            onRender.call(item, itemEventOptions);
        }

        if (onItemRender) {
            onItemRender.call(self, item, itemEventOptions);
        }

        triggerOne(item, 'render', itemEventOptions);

        return { node: node, itemEventOptions: itemEventOptions };
    }

    return { node: node };
}
//# sourceMappingURL=renderitemnode.js.map