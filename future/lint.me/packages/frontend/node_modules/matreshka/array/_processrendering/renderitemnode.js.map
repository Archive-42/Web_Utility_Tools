{"version":3,"sources":["../../../src/array/_processrendering/renderitemnode.js"],"names":["htmlTestReg","renderItemNode","selfDef","self","item","eventOptions","renderer","bindRenderedAsSandbox","itemRenderer","usedRenderer","rendererContext","selfId","id","moveSandbox","forceRerender","silent","node","itemDef","initMK","renderedInArrays","sandboxPropDef","props","sandbox","bindings","i","keys","Object","length","key","itemEventOptions","parentArray","call","test","selector","getNodes","innerHTML","trim","matreshkaError","parsed","parseBindings","unbindNode","bindNode","onRender","onItemRender","triggerOne"],"mappings":"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","file":"renderitemnode.js","sourcesContent":["import parseBindings from '../../parsebindings';\nimport bindNode from '../../bindnode';\nimport unbindNode from '../../unbindnode';\nimport triggerOne from '../../trigger/_triggerone';\nimport initMK from '../../_core/init';\nimport matreshkaError from '../../_helpers/matreshkaerror';\nimport getNodes from '../../bindnode/_getnodes';\n\nconst htmlTestReg = /</;\n\n// the function makes the main rendering job\n// it renders given array item\nexport default function renderItemNode({\n    selfDef, // selfDef is passed as little optimization\n    self,\n    item,\n    eventOptions\n}) {\n    const { renderer, bindRenderedAsSandbox = true } = item;\n    const { itemRenderer } = self;\n    let usedRenderer = renderer || itemRenderer;\n    const rendererContext = usedRenderer === renderer ? item : self;\n    const { id: selfId } = selfDef;\n    const {\n        moveSandbox,\n        forceRerender,\n        silent\n    } = eventOptions;\n\n    // if renderer is not found return null as a node\n    if (!usedRenderer) {\n        return { node: null };\n    }\n\n    const itemDef = initMK(item);\n    const { renderedInArrays = {} } = itemDef;\n\n    // if moveSandbox option is truthy then return a sandbox of an item\n    if (moveSandbox) {\n        const sandboxPropDef = itemDef.props.sandbox;\n        if (sandboxPropDef) {\n            const { bindings } = sandboxPropDef;\n            const node = bindings ? bindings[0].node : null;\n\n            if (node) {\n                for (let i = 0, keys = Object.keys(renderedInArrays); i < keys.length; i++) {\n                    const key = keys[i];\n\n                    if (node === renderedInArrays[key]) {\n                        // delete an information about previous array\n                        delete renderedInArrays[key];\n                        break;\n                    }\n                }\n\n                renderedInArrays[selfId] = node;\n\n                // moving sandbox does not fire \"render\" event but it fire \"afterrender\"\n                // since \"afterrender\" means \"node is inserted to DOM\"\n                return {\n                    node,\n                    itemEventOptions: {\n                        node,\n                        self: item,\n                        parentArray: self\n                    }\n                };\n            }\n        }\n    }\n\n    itemDef.renderedInArrays = renderedInArrays;\n\n    // if usedRenderer is function then call it\n    if (typeof usedRenderer === 'function') {\n        usedRenderer = usedRenderer.call(rendererContext, item);\n    }\n\n\n    // if usedRenderer is string\n    if (typeof usedRenderer === 'string') {\n        if (!htmlTestReg.test(usedRenderer)) {\n            // if usedRenderer is a selector\n            const selector = usedRenderer;\n\n            usedRenderer = getNodes(self, selector);\n\n            if (usedRenderer.length) {\n                // if a node is found by given selector then use its HTML\n                usedRenderer = usedRenderer[0].innerHTML.trim();\n            } else {\n                // if not throw an error\n                throw matreshkaError('array:renderer_node_missing', { selector });\n            }\n        } else {\n            // if usedRenderer is HTML string\n            usedRenderer = usedRenderer.trim();\n        }\n    }\n\n    // pass a node or HTML\n    const parsed = parseBindings(item, usedRenderer, eventOptions);\n\n    // if parseBindings returned more/less than one node then throw an error\n    if (parsed.length !== 1) {\n        throw matreshkaError('array:rendered_number_nodes', { length: parsed.length });\n    }\n\n    const node = renderedInArrays[selfId] = parsed[0];\n\n    if (bindRenderedAsSandbox) {\n        if (forceRerender) {\n            unbindNode(item, 'sandbox', null, null, eventOptions);\n        }\n\n        bindNode(item, 'sandbox', node, null, eventOptions);\n    }\n\n    // if silent is not truthy then fire 'render' event and virtual methods\n    if (!silent) {\n        const itemEventOptions = {\n            node,\n            self: item,\n            parentArray: self\n        };\n        const { onRender } = item;\n        const { onItemRender } = self;\n\n        if (onRender) {\n            onRender.call(item, itemEventOptions);\n        }\n\n        if (onItemRender) {\n            onItemRender.call(self, item, itemEventOptions);\n        }\n\n        triggerOne(item, 'render', itemEventOptions);\n\n        return { node, itemEventOptions };\n    }\n\n    return { node };\n}\n"]}