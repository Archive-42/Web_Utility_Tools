'use strict';

var toMatreshkaArray = require('../_tomatreshkaarray');

var createSortingMethod = require('./createsortingmethod');

var createRemovingMethod = require('./createremovingmethod');

var createAddingMethod = require('./createaddingmethod');

var createSplice = require('./createsplice');

var createCopyWithin = require('./createcopywithin');

var createFill = require('./createfill');

var apply = require('../../_helpers/apply');

var matreshkaError = require('../../_helpers/matreshkaerror');

var arrayPrototype = Array.prototype;

// creates pseudo native method and returns it (push, push_, sort, sort_...)
module.exports = createPseudoNativeMethod;
function createPseudoNativeMethod(name) {
    var hasOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    switch (name) {
        case 'forEach':
            return function pseudoNativeMethod(callback, thisArg) {
                arrayPrototype[name].call(this, callback, thisArg);
                // return this for nicer chain calls
                return this;
            };
        case 'map':
        case 'filter':
        case 'slice':
            // TODO: Improve readability of pseudoNativeMethod, arguments "a, b" look not good
            return function pseudoNativeMethod(a, b) {
                return toMatreshkaArray(arrayPrototype[name].call(this, a, b));
            };
        case 'every':
        case 'some':
        case 'findIndex':
        case 'find':
            return function pseudoNativeMethod(callback, thisArg) {
                var originalMethod = arrayPrototype[name];

                /* istanbul ignore if  */
                if (typeof originalMethod !== 'function') {
                    throw matreshkaError('array:nonexistent_method', { method: name });
                }
                return originalMethod.call(this, callback, thisArg);
            };
        case 'join':
            return function pseudoNativeMethod() {
                var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ',';

                return arrayPrototype[name].call(this, separator);
            };
        case 'indexOf':
        case 'lastIndexOf':
        case 'includes':
            return function pseudoNativeMethod(searchElement, fromIndex) {
                var originalMethod = arrayPrototype[name];

                /* istanbul ignore if  */
                if (typeof originalMethod !== 'function') {
                    throw matreshkaError('array:nonexistent_method', { method: name });
                }

                if (typeof fromIndex === 'undefined') {
                    return originalMethod.call(this, searchElement);
                }

                return originalMethod.call(this, searchElement, fromIndex);
            };
        case 'reduce':
        case 'reduceRight':
            return function pseudoNativeMethod() {
                return apply(arrayPrototype[name], this, arguments);
            };
        case 'sort':
        case 'reverse':
            return createSortingMethod(name, hasOptions);
        case 'pop':
        case 'shift':
            return createRemovingMethod(name, hasOptions);
        case 'push':
        case 'unshift':
            return createAddingMethod(name, hasOptions);
        case 'splice':
            return createSplice(hasOptions);
        case 'copyWithin':
            return createCopyWithin(hasOptions);
        case 'fill':
            return createFill(hasOptions);
        default:
            return undefined;
    }
}
//# sourceMappingURL=createpseudonativemethod.js.map