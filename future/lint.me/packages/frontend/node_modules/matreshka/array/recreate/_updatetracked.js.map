{"version":3,"sources":["../../../src/array/recreate/_updatetracked.js"],"names":["updateTracked","givenNewItems","arr","trackBy","newLength","length","oldLength","newItems","Array","i","item","newItem","updateObject","trackMap"],"mappings":";;2BAAyB,iB;;AAEzB;AACA;iBACwBA,a;AAAT,SAASA,aAAT,OAIZ;AAAA,QAHCC,aAGD,QAHCA,aAGD;AAAA,QAFCC,GAED,QAFCA,GAED;AAAA,QADCC,OACD,QADCA,OACD;;AACC,QAAMC,YAAYH,cAAcI,MAAhC;AACA,QAAMC,YAAYJ,IAAIG,MAAtB;AACA,QAAME,WAAWC,MAAMJ,SAAN,CAAjB;;AAEA,QAAID,YAAY,QAAhB,EAA0B;AACtB;AACA,aAAK,IAAIM,IAAI,CAAb,EAAgBA,IAAIL,SAApB,EAA+BK,GAA/B,EAAoC;AAChC,gBAAMC,OAAOR,IAAIO,CAAJ,CAAb;AACA,gBAAME,UAAUV,cAAcQ,CAAd,CAAhB;;AAEA,gBACIC,QAAQ,OAAOA,IAAP,KAAgB,QAAxB,IACGC,OADH,IACc,OAAOA,OAAP,KAAmB,QAFrC,EAGE;AACEJ,yBAASE,CAAT,IAAcG,aAAaF,IAAb,EAAmBC,OAAnB,CAAd;AACH,aALD,MAKO;AACHJ,yBAASE,CAAT,IAAcE,OAAd;AACH;AACJ;AACJ,KAfD,MAeO;AACH,YAAME,WAAW,EAAjB;;AAEA;AACA,aAAK,IAAIJ,KAAI,CAAb,EAAgBA,KAAIH,SAApB,EAA+BG,IAA/B,EAAoC;AAChC,gBAAMC,QAAOR,IAAIO,EAAJ,CAAb;;AAEA,gBAAIC,SAAQ,OAAOA,KAAP,KAAgB,QAA5B,EAAsC;AAClC,oBAAIP,WAAWO,KAAf,EAAqB;AACjBG,6BAASH,MAAKP,OAAL,CAAT,IAA0BO,KAA1B;AACH;AACJ;AACJ;;AAED,aAAK,IAAID,MAAI,CAAb,EAAgBA,MAAIL,SAApB,EAA+BK,KAA/B,EAAoC;AAChC,gBAAME,WAAUV,cAAcQ,GAAd,CAAhB;;AAEA,gBAAIE,YAAW,OAAOA,QAAP,KAAmB,QAAlC,EAA4C;AACxC,oBAAMD,SAAOR,IAAIO,GAAJ,CAAb;;AAEA,oBAAIC,UAAQ,OAAOA,MAAP,KAAgB,QAAxB,IAAoCC,SAAQR,OAAR,KAAoBU,QAA5D,EAAsE;AAClE;AACAN,6BAASE,GAAT,IAAcG,aAAaC,SAASF,SAAQR,OAAR,CAAT,CAAb,EAAyCQ,QAAzC,CAAd;AACH,iBAHD,MAGO;AACH;AACAJ,6BAASE,GAAT,IAAcE,QAAd;AACH;AACJ,aAVD,MAUO;AACH;AACAJ,yBAASE,GAAT,IAAcE,QAAd;AACH;AACJ;AACJ;;AAED,WAAOJ,QAAP;AACH","file":"_updatetracked.js","sourcesContent":["import updateObject from './_updateobject';\n\n// the function gets called to update new items passed to recreate method when trackBy is present\n// TODO: Throw an error when two or more items of one array has the same value of trackBy\nexport default function updateTracked({\n    givenNewItems,\n    arr,\n    trackBy\n}) {\n    const newLength = givenNewItems.length;\n    const oldLength = arr.length;\n    const newItems = Array(newLength);\n\n    if (trackBy === '$index') {\n        // simply update items with the same index\n        for (let i = 0; i < newLength; i++) {\n            const item = arr[i];\n            const newItem = givenNewItems[i];\n\n            if (\n                item && typeof item === 'object'\n                && newItem && typeof newItem === 'object'\n            ) {\n                newItems[i] = updateObject(item, newItem);\n            } else {\n                newItems[i] = newItem;\n            }\n        }\n    } else {\n        const trackMap = {};\n\n        // fill trackMap object where keys are values of trackBy and values are corresponding items\n        for (let i = 0; i < oldLength; i++) {\n            const item = arr[i];\n\n            if (item && typeof item === 'object') {\n                if (trackBy in item) {\n                    trackMap[item[trackBy]] = item;\n                }\n            }\n        }\n\n        for (let i = 0; i < newLength; i++) {\n            const newItem = givenNewItems[i];\n\n            if (newItem && typeof newItem === 'object') {\n                const item = arr[i];\n\n                if (item && typeof item === 'object' && newItem[trackBy] in trackMap) {\n                    // if an item exists at trackMap then update it\n                    newItems[i] = updateObject(trackMap[newItem[trackBy]], newItem);\n                } else {\n                    // if not then use new value as is\n                    newItems[i] = newItem;\n                }\n            } else {\n                // newItem is not an object\n                newItems[i] = newItem;\n            }\n        }\n    }\n\n    return newItems;\n}\n"]}