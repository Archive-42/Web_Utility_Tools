'use strict';

var initMK = require('../../_core/init');

var reportModified = require('../_reportmodified');

var updateTracked = require('./_updatetracked');

// recreates an array
module.exports = recreate;
function recreate() {
    var givenNewItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var eventOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var def = initMK(this);
    var itemMediator = def.itemMediator;

    var newLength = givenNewItems.length;
    var oldLength = this.length;
    var lengthDiff = oldLength - newLength;
    var was = this.toJSON(false);
    var trackBy = this.trackBy;
    var skipItemMediator = eventOptions.skipItemMediator,
        silent = eventOptions.silent,
        dontRender = eventOptions.dontRender;

    var added = void 0;
    var removed = void 0;
    var newItems = void 0;

    if (trackBy) {
        // if trackBy property is given then update givenNewItems array
        newItems = updateTracked({
            arr: this,
            givenNewItems: givenNewItems,
            trackBy: trackBy
        });
    } else {
        // if trackBy is not given then use given new items as is
        newItems = givenNewItems;
    }

    // call item mediator for every new item (but don't modify passed newItems)
    if (itemMediator && !skipItemMediator) {
        var toMediate = newItems;
        newItems = Array(newLength);
        for (var i = 0; i < newLength; i++) {
            newItems[i] = itemMediator(toMediate[i], i);
        }
    }

    // update array indexes with new values
    for (var _i = 0; _i < newLength; _i++) {
        this[_i] = newItems[_i];
    }

    // remove old items that is out of new length
    for (var _i2 = 0; _i2 < lengthDiff; _i2++) {
        delete this[_i2 + newLength];
    }

    // update length
    this.length = newLength;

    if (silent && dontRender) {
        return this;
    }

    // create an array of removed items
    // TODO: Optimize creation of "added" and "removed" options in recreate method
    // ... (do not use indexOf)
    if (newLength) {
        if (oldLength) {
            removed = [];
            for (var _i3 = 0; _i3 < oldLength; _i3++) {
                if (!~newItems.indexOf(was[_i3])) {
                    removed.push(was[_i3]);
                }
            }
        } else {
            removed = [];
        }
    } else {
        removed = was;
    }

    // create an array of added items
    if (oldLength) {
        if (newLength) {
            added = [];
            for (var _i4 = 0; _i4 < newLength; _i4++) {
                if (!~was.indexOf(newItems[_i4])) {
                    added.push(newItems[_i4]);
                }
            }
        } else {
            added = [];
        }
    } else {
        added = newItems;
    }

    var _keys,
        _l,
        _i5,
        _source,
        _key,
        _result = {};

    _result.added = added
    _result.removed = removed
    _result.method = 'recreate'
    _result.self = this

    for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i5 = 0; _i5 < _l; _i5++) {
        _key = _keys[_i5];
        _result[_key] = _source[_key];
    }

    reportModified(this, _result);

    return this;
}
//# sourceMappingURL=index.js.map