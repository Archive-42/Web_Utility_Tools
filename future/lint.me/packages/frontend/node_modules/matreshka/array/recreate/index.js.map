{"version":3,"sources":["../../../src/array/recreate/index.js"],"names":["recreate","givenNewItems","eventOptions","def","initMK","itemMediator","newLength","length","oldLength","lengthDiff","was","toJSON","trackBy","skipItemMediator","silent","dontRender","added","removed","newItems","updateTracked","arr","toMediate","Array","i","indexOf","push","method","self","reportModified"],"mappings":"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","file":"index.js","sourcesContent":["import initMK from '../../_core/init';\nimport reportModified from '../_reportmodified';\nimport updateTracked from './_updatetracked';\n\n// recreates an array\nexport default function recreate(givenNewItems = [], eventOptions = {}) {\n    const def = initMK(this);\n    const { itemMediator } = def;\n    const newLength = givenNewItems.length;\n    const oldLength = this.length;\n    const lengthDiff = oldLength - newLength;\n    const was = this.toJSON(false);\n    const { trackBy } = this;\n    const { skipItemMediator, silent, dontRender } = eventOptions;\n    let added;\n    let removed;\n    let newItems;\n\n    if (trackBy) {\n        // if trackBy property is given then update givenNewItems array\n        newItems = updateTracked({\n            arr: this,\n            givenNewItems,\n            trackBy\n        });\n    } else {\n        // if trackBy is not given then use given new items as is\n        newItems = givenNewItems;\n    }\n\n    // call item mediator for every new item (but don't modify passed newItems)\n    if (itemMediator && !skipItemMediator) {\n        const toMediate = newItems;\n        newItems = Array(newLength);\n        for (let i = 0; i < newLength; i++) {\n            newItems[i] = itemMediator(toMediate[i], i);\n        }\n    }\n\n    // update array indexes with new values\n    for (let i = 0; i < newLength; i++) {\n        this[i] = newItems[i];\n    }\n\n    // remove old items that is out of new length\n    for (let i = 0; i < lengthDiff; i++) {\n        delete this[i + newLength];\n    }\n\n    // update length\n    this.length = newLength;\n\n    if (silent && dontRender) {\n        return this;\n    }\n\n    // create an array of removed items\n    // TODO: Optimize creation of \"added\" and \"removed\" options in recreate method\n    // ... (do not use indexOf)\n    if (newLength) {\n        if (oldLength) {\n            removed = [];\n            for (let i = 0; i < oldLength; i++) {\n                if (!~newItems.indexOf(was[i])) {\n                    removed.push(was[i]);\n                }\n            }\n        } else {\n            removed = [];\n        }\n    } else {\n        removed = was;\n    }\n\n    // create an array of added items\n    if (oldLength) {\n        if (newLength) {\n            added = [];\n            for (let i = 0; i < newLength; i++) {\n                if (!~was.indexOf(newItems[i])) {\n                    added.push(newItems[i]);\n                }\n            }\n        } else {\n            added = [];\n        }\n    } else {\n        added = newItems;\n    }\n\n    reportModified(this, {\n        added,\n        removed,\n        method: 'recreate',\n        self: this,\n        ...eventOptions\n    });\n\n    return this;\n}\n"]}