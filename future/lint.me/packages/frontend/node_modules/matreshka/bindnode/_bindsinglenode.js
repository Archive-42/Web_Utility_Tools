'use strict';

var lookForBinder = require('../lookforbinder');

var createNodeHandler = require('./_createnodehandler');

var createObjectHandler = require('./_createobjecthandler');

var triggerOne = require('../trigger/_triggerone');

var addListener = require('../on/_addlistener');

var debounce = require('../_helpers/debounce');

var matreshkaError = require('../_helpers/matreshkaerror');

var spaceReg = /\s+/;

// handles binding for single property & node
// the function is used at bindNode
module.exports = bindSingleNode;
function bindSingleNode(object, _ref) {
    var givenBinder = _ref.binder,
        key = _ref.key,
        $nodes = _ref.$nodes,
        node = _ref.node,
        eventOptions = _ref.eventOptions,
        propDef = _ref.propDef;
    var silent = eventOptions.silent,
        getValueOnBind = eventOptions.getValueOnBind,
        setValueOnBind = eventOptions.setValueOnBind,
        _eventOptions$debounc = eventOptions.debounceSetValue,
        debounceSetValue = _eventOptions$debounc === undefined ? true : _eventOptions$debounc,
        _eventOptions$debounc2 = eventOptions.debounceGetValue,
        debounceGetValue = _eventOptions$debounc2 === undefined ? true : _eventOptions$debounc2,
        _eventOptions$debounc3 = eventOptions.debounceSetValueOnBind,
        debounceSetValueOnBind = _eventOptions$debounc3 === undefined ? false : _eventOptions$debounc3,
        _eventOptions$debounc4 = eventOptions.debounceGetValueOnBind,
        debounceGetValueOnBind = _eventOptions$debounc4 === undefined ? false : _eventOptions$debounc4,
        _eventOptions$debounc5 = eventOptions.debounceSetValueDelay,
        debounceSetValueDelay = _eventOptions$debounc5 === undefined ? 0 : _eventOptions$debounc5,
        _eventOptions$debounc6 = eventOptions.debounceGetValueDelay,
        debounceGetValueDelay = _eventOptions$debounc6 === undefined ? 0 : _eventOptions$debounc6,
        _eventOptions$useExac = eventOptions.useExactBinder,
        useExactBinder = _eventOptions$useExac === undefined ? false : _eventOptions$useExac;
    // create bindings array in property definition object

    var bindings = propDef.bindings = propDef.bindings || [];
    var value = propDef.value;

    var bindingOptions = {
        self: object,
        key: key,
        value: value,
        $nodes: $nodes,
        node: node
    };
    var isUndefined = typeof value === 'undefined';
    var binder = void 0;
    var objectHandler = void 0;
    var nodeHandler = void 0;

    // do not allow to bind more than 2 nodes to "sandbox" (for all nodes)
    // and "container" (for Matreshka.Array)
    if (bindings.length && (key === 'sandbox' || object.isMatreshkaArray && key === 'container')) {
        throw matreshkaError('binding:magic_props_nodes_length');
    }

    // get actual binder
    if (givenBinder !== null) {
        // by default binder passed to bindNode is extended by default binder
        // useExactBinder turns this behavior off
        if (useExactBinder) {
            binder = givenBinder;
        } else {
            // getting default binder
            var foundBinder = lookForBinder(node);

            // if default binder is found
            if (foundBinder) {
                // extend found binder by given binder
                if (givenBinder) {
                    var _result = foundBinder;

                    for (var _source2 = givenBinder, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {
                        _key2 = _keys2[_i2];
                        _result[_key2] = _source2[_key2];
                    }
                }

                binder = foundBinder;
            } else {
                // default binder is not found
                binder = givenBinder || {};
            }
        }
    }

    var _binder = binder,
        getValue = _binder.getValue,
        setValue = _binder.setValue,
        on = _binder.on,
        initialize = _binder.initialize;

    // call binder.initialize

    if (initialize) {
        initialize.call(node, bindingOptions);
    }

    // add needed event handlers to given node when getValue is given
    if (getValue) {
        var syncNodeHandler = createNodeHandler({
            object: object,
            key: key,
            node: node,
            propDef: propDef,
            binder: binder,
            bindingOptions: bindingOptions
        });

        var debouncedNodeHandler = void 0;

        if (debounceGetValue || debounceGetValueOnBind) {
            debouncedNodeHandler = debounce(syncNodeHandler, debounceGetValueDelay);
        }

        if (debounceGetValue) {
            nodeHandler = debouncedNodeHandler;
        } else {
            nodeHandler = syncNodeHandler;
        }

        // TODO: Throw error when "on" and maybe other binder properties has wrong type
        if (typeof on === 'function') {
            on.call(node, nodeHandler, bindingOptions);
        } else if (typeof on === 'string') {
            for (var _target = on.split(spaceReg), _index = 0, evtName, _l3 = _target.length; evtName = _target[_index], _index < _l3; _index++) {
                node.addEventListener(evtName, nodeHandler)
            }
            // addEventListener is faster than "on" method from any DOM library

        }

        if (isUndefined && getValueOnBind !== false || getValueOnBind === true) {
            if (debounceGetValueOnBind) {
                debouncedNodeHandler();
            } else {
                syncNodeHandler();
            }
        }

        isUndefined = typeof propDef.value === 'undefined';
    }

    // add needed event handlers to the object when setValue is given
    if (setValue) {
        var syncObjectHandler = createObjectHandler({
            node: node,
            propDef: propDef,
            binder: binder,
            bindingOptions: bindingOptions,
            eventOptions: eventOptions
        });

        var debouncedObjectHandler = void 0;

        if (debounceSetValue || debounceSetValueOnBind) {
            debouncedObjectHandler = debounce(syncObjectHandler, debounceSetValueDelay);
        }

        if (debounceSetValue) {
            objectHandler = debouncedObjectHandler;
        } else {
            objectHandler = syncObjectHandler;
        }

        // TODO: Is it possible to get previous value of a property?
        addListener(object, '_change:bindings:' + key, objectHandler, null, { skipChecks: true });

        if (!isUndefined && setValueOnBind !== false || setValueOnBind === true) {
            if (debounceSetValueOnBind) {
                debouncedObjectHandler();
            } else {
                syncObjectHandler();
            }
        }
    }

    // add binding data to bindings array
    bindings.push({
        on: on,
        node: node,
        binder: binder,
        objectHandler: objectHandler,
        nodeHandler: nodeHandler,
        bindingOptions: bindingOptions
    });

    // fire events
    if (!silent) {
        var _keys3,
            _l4,
            _i3,
            _source3,
            _key3,
            _result2 = {};

        _result2.key = key
        _result2.node = node

        for (_source3 = eventOptions, _keys3 = Object.keys(_source3), _l4 = _keys3.length, _i3 = 0; _i3 < _l4; _i3++) {
            _key3 = _keys3[_i3];
            _result2[_key3] = _source3[_key3];
        }

        var extendedEventOptions = _result2;

        triggerOne(object, 'bind:' + key, extendedEventOptions);
        triggerOne(object, 'bind', extendedEventOptions);
    }
}
//# sourceMappingURL=_bindsinglenode.js.map