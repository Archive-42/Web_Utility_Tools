'use strict';

var unbindNode = require('../unbindnode');

// returns a function which re-adds binding when object branch is changed
// the function is called by bindNode when something like
// 'foo.bar.baz' is passed to it as key argument value
// this is one of the hardest things in the framework to understand
module.exports = createBindingSwitcher;
function createBindingSwitcher(_ref) {
    var object = _ref.object,
        deepPath = _ref.deepPath,
        $nodes = _ref.$nodes,
        binder = _ref.binder,
        eventOptions = _ref.eventOptions,
        bindNode = _ref.bindNode;

    return function bindingSwitcher() {
        var changeEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var deepPathLength = deepPath.length;
        var lastDeepPathItem = deepPath[deepPathLength - 1];
        var value = changeEvent.value,
            previousValue = changeEvent.previousValue,
            restPath = changeEvent.restPath;

        var target = void 0; // an object to call bindNode
        var previousTarget = void 0; // an object to call unbindNode


        if (value && typeof value === 'object' && restPath) {
            // if rest path is given and new value is an object
            target = value;
            for (var i = 0; i < restPath.length; i++) {
                target = target[restPath[i]];
                if (!target) {
                    break;
                }
            }
        } else {
            // if rest path is not given
            target = object;
            for (var _i = 0; _i < deepPathLength - 1; _i++) {
                target = target[deepPath[_i]];
                if (!target) {
                    break;
                }
            }
        }

        // if rest path is given and previous value is an object
        if (previousValue && typeof previousValue === 'object' && restPath) {
            previousTarget = previousValue;
            for (var _i2 = 0; _i2 < restPath.length; _i2++) {
                previousTarget = previousTarget[restPath[_i2]];
                if (!previousTarget) {
                    break;
                }
            }
        }

        // add binding for new target
        if (target && typeof target === 'object') {
            bindNode(target, lastDeepPathItem, $nodes, binder, eventOptions);
        }

        // remove binding for previously used object
        if (previousTarget && typeof previousTarget === 'object') {
            unbindNode(previousTarget, lastDeepPathItem, $nodes);
        }
    };
}
//# sourceMappingURL=_createbindingswitcher.js.map