'use strict';

var initMK = require('../_core/init');

var defineProp = require('../_core/defineprop');

var getNodes = require('./_getnodes');

var createBindingSwitcher = require('./_createbindingswitcher');

var bindSingleNode = require('./_bindsinglenode');

var checkObjectType = require('../_helpers/checkobjecttype');

var matreshkaError = require('../_helpers/matreshkaerror');

var addTreeListener = require('../on/_addtreelistener');

// initializes binsing between a property of an object to HTML node
module.exports = bindNode;
function bindNode(object, key, node, binder, eventOptions) {
    if (typeof this === 'object' && this.isMatreshka) {
        // when context is Matreshka instance, use this as an object and shift other args
        /* eslint-disable no-param-reassign */
        eventOptions = binder;
        binder = node;
        node = key;
        key = object;
        object = this;
        /* eslint-enable no-param-reassign */
    } else {
        // throw error when object type is wrong
        checkObjectType(object, 'bindNode');
    }

    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign
    binder = binder || {}; // eslint-disable-line no-param-reassign

    initMK(object);

    var temporaryOptionalFlag = bindNode.temporaryOptionalFlag;


    delete bindNode.temporaryOptionalFlag;

    // throw an error when key is falsy
    if (!key) {
        throw matreshkaError('binding:falsy_key');
    }

    if (key instanceof Array) {
        if (typeof key[0] === 'string') {
            /*
             * accept array of keys
             * this.bindNode(['a', 'b', 'c'], node)
             */
            if (temporaryOptionalFlag) {
                var _keys,
                    _l,
                    _i,
                    _source,
                    _key,
                    _result = {};

                for (_source = eventOptions, _keys = Object.keys(_source), _l = _keys.length, _i = 0; _i < _l; _i++) {
                    _key = _keys[_i];
                    _result[_key] = _source[_key];
                }

                _result.optional = true

                // eslint-disable-next-line no-param-reassign
                eventOptions = _result;
            }

            for (var _target = key, _index = 0, itemKey, _l2 = _target.length; itemKey = _target[_index], _index < _l2; _index++) {
                bindNode(object, itemKey, node, binder, eventOptions)
            }
        } else {
            for (var _target2 = key, _index2 = 0, _ref, _l7 = _target2.length; _ref = _target2[_index2], _index2 < _l7; _index2++) {
                var itemKey = _ref.key,
                    itemNode = _ref.node,
                    itemBinder = _ref.binder,
                    itemEventOptions = _ref.event;

                var commonEventOptions = node;
                var mergedEventOptions = {};

                if (temporaryOptionalFlag) {
                    mergedEventOptions.optional = true;
                }

                if (commonEventOptions) {
                    var _result2 = mergedEventOptions;
                    // extend event object by "global" event

                    for (var _source3 = commonEventOptions, _keys3 = Object.keys(_source3), _l4 = _keys3.length, _i3 = 0, _key3; _i3 < _l4; _i3++) {
                        _key3 = _keys3[_i3];
                        _result2[_key3] = _source3[_key3];
                    }
                }

                if (itemEventOptions) {
                    var _result3 = mergedEventOptions;
                    // extend event object by "local" event ("event" key of an object)

                    for (var _source5 = itemEventOptions, _keys5 = Object.keys(_source5), _l6 = _keys5.length, _i5 = 0, _key5; _i5 < _l6; _i5++) {
                        _key5 = _keys5[_i5];
                        _result3[_key5] = _source5[_key5];
                    }
                }

                bindNode(object, itemKey, itemNode, itemBinder, mergedEventOptions);
            }
            /*
             * accept array of objects
             * this.bindNode([{key, node, binder, event}], { silent: true });
             */

        }

        return object;
    }

    if (typeof key === 'object') {
        for (var _target4 = key, _keys7 = Object.keys(_target4), _i7 = 0, keyObjKey, keyObjValue, _l10 = _keys7.length; (keyObjKey = _keys7[_i7], keyObjValue = _target4[keyObjKey]), _i7 < _l10; _i7++) {
            // binder means eventOptions
            if (temporaryOptionalFlag) {
                var _keys6,
                    _l8,
                    _i6,
                    _source6,
                    _key6,
                    _result4 = {};

                for (_source6 = binder, _keys6 = Object.keys(_source6), _l8 = _keys6.length, _i6 = 0; _i6 < _l8; _i6++) {
                    _key6 = _keys6[_i6];
                    _result4[_key6] = _source6[_key6];
                }

                _result4.optional = true

                // eslint-disable-next-line no-param-reassign
                eventOptions = binder ? _result4 : { optional: true };
            } else {
                eventOptions = binder; // eslint-disable-line no-param-reassign
            }

            if (keyObjValue && keyObjValue.constructor === Object && 'node' in keyObjValue) {
                // this.bindNode({ key: { node: $(), binder } ) }, { on: 'evt' }, { silent: true });
                bindNode(object, keyObjKey, keyObjValue.node, keyObjValue.binder || node, eventOptions);
            } else if (keyObjValue && keyObjValue.constructor === Array && keyObjValue.length && keyObjValue[0].constructor === Object && 'node' in keyObjValue[0]) {
                for (var _target3 = keyObjValue, _index3 = 0, keyObjValueItem, _l9 = _target3.length; keyObjValueItem = _target3[_index3], _index3 < _l9; _index3++) {
                    bindNode(object, keyObjKey, keyObjValueItem.node, keyObjValueItem.binder || node, eventOptions);
                }
                // this.bindNode({ key: [{
                //   node: $(),
                //   binder
                // }] ) }, { on: 'evt' }, { silent: true });

            } else {
                // this.bindNode({ key: $() }, { on: 'evt' }, { silent: true });
                bindNode(object, keyObjKey, keyObjValue, node, eventOptions);
            }
        }

        return object;
    }

    var _eventOptions = eventOptions,
        _eventOptions$optiona = _eventOptions.optional,
        optional = _eventOptions$optiona === undefined ? temporaryOptionalFlag || false : _eventOptions$optiona,
        _eventOptions$exactKe = _eventOptions.exactKey,
        exactKey = _eventOptions$exactKe === undefined ? false : _eventOptions$exactKe;

    var $nodes = getNodes(object, node);

    // check node existence
    if (!$nodes.length) {
        if (optional) {
            return object;
        }

        throw matreshkaError('binding:node_missing', { key: key, node: node });
    }

    if (!exactKey) {
        var deepPath = key.split('.');
        var deepPathLength = deepPath.length;

        if (deepPathLength > 1) {
            // handle binding when key arg includes dots (eg "a.b.c.d")
            var bindingSwitcher = createBindingSwitcher({
                object: object,
                deepPath: deepPath,
                $nodes: $nodes,
                binder: binder,
                eventOptions: eventOptions,
                bindNode: bindNode
            });

            addTreeListener(object, deepPath.slice(0, deepPathLength - 1), bindingSwitcher);

            bindingSwitcher();

            return object;
        }
    }

    var propDef = defineProp(object, key);

    if (object.isMatreshka) {
        // if an object is Matreshka instance then extend "$nodes" and "nodes" objects
        var _object = object,
            $allNodes = _object.$nodes,
            allNodes = _object.nodes;


        if (!$allNodes || !allNodes) {
            throw matreshkaError('binding:instance_nodes_missing', {
                $nodes: $allNodes,
                nodes: allNodes
            });
        }

        $allNodes[key] = $allNodes[key] && $allNodes[key].length ? $allNodes[key].add($nodes) : $nodes;

        allNodes[key] = $allNodes[key][0];
    }

    // handle binding for every node separately

    for (var _target5 = $nodes, _index4 = 0, oneNode, _l11 = _target5.length; oneNode = _target5[_index4], _index4 < _l11; _index4++) {
        bindSingleNode(object, {
            $nodes: $nodes,
            node: oneNode,
            key: key,
            eventOptions: eventOptions,
            binder: binder,
            propDef: propDef
        })
    }

    return object;
}
//# sourceMappingURL=index.js.map