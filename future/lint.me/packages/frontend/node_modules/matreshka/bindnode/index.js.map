{"version":3,"sources":["../../src/bindnode/index.js"],"names":["bindNode","object","key","node","binder","eventOptions","isMatreshka","checkObjectType","initMK","temporaryOptionalFlag","matreshkaError","Array","optional","itemKey","itemNode","itemBinder","itemEventOptions","event","commonEventOptions","mergedEventOptions","keyObjKey","keyObjValue","constructor","Object","length","keyObjValueItem","exactKey","$nodes","getNodes","deepPath","split","deepPathLength","bindingSwitcher","createBindingSwitcher","addTreeListener","slice","propDef","defineProp","$allNodes","allNodes","nodes","add","oneNode","bindSingleNode"],"mappings":";;qBAAmB,e;;yBACI,qB;;uBACF,a;;oCACa,0B;;6BACP,mB;;8BACC,6B;;6BACD,4B;;8BACC,wB;;AAE5B;iBACwBA,Q;AAAT,SAASA,QAAT,CAAkBC,MAAlB,EAA0BC,GAA1B,EAA+BC,IAA/B,EAAqCC,MAArC,EAA6CC,YAA7C,EAA2D;AACtE,QAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,KAAKC,WAArC,EAAkD;AAC9C;AACA;AACAD,uBAAeD,MAAf;AACAA,iBAASD,IAAT;AACAA,eAAOD,GAAP;AACAA,cAAMD,MAAN;AACAA,iBAAS,IAAT;AACA;AACH,KATD,MASO;AACH;AACAM,wBAAgBN,MAAhB,EAAwB,UAAxB;AACH;;AAEDI,mBAAeA,gBAAgB,EAA/B,CAfsE,CAenC;AACnCD,aAASA,UAAU,EAAnB,CAhBsE,CAgB/C;;AAEvBI,WAAOP,MAAP;;AAlBsE,QAoB9DQ,qBApB8D,GAoBpCT,QApBoC,CAoB9DS,qBApB8D;;;AAsBtE,WAAOT,SAASS,qBAAhB;;AAEA;AACA,QAAI,CAACP,GAAL,EAAU;AACN,cAAMQ,eAAe,mBAAf,CAAN;AACH;;AAED,QAAIR,eAAeS,KAAnB,EAA0B;AACtB,YAAI,OAAOT,IAAI,CAAJ,CAAP,KAAkB,QAAtB,EAAgC;AAC5B;;;;AAIA,gBAAIO,qBAAJ,EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,+BAEHJ,YAFG;AAAA;AAAA;AAAA;;AAAA,wBAEWO,QAFX,GAEqB;;AAD5C;AACAP;AACH;;AAR2B,+BAUfH,GAVe,cAUVW,OAVU,wBAUVA,OAVU;AAUCb,yBAASC,MAAT,EAAiBY,OAAjB,EAA0BV,IAA1B,EAAgCC,MAAhC,EAAwCC,YAAxC;AAVD;AAW/B,SAXD,MAWO;AAAA,gCAKUH,GALV,gGAUG;AAAA,oBAJGW,OAIH,QAJFX,GAIE;AAAA,oBAHIY,QAGJ,QAHFX,IAGE;AAAA,oBAFMY,UAEN,QAFFX,MAEE;AAAA,oBADKY,gBACL,QADFC,KACE;;AACF,oBAAMC,qBAAqBf,IAA3B;AACA,oBAAMgB,qBAAqB,EAA3B;;AAEA,oBAAIV,qBAAJ,EAA2B;AACvBU,uCAAmBP,QAAnB,GAA8B,IAA9B;AACH;;AAED,oBAAIM,kBAAJ,EAAwB;AAAA,mCAERC,kBAFQ;AACpB;;AADoB,wCAEYD,kBAFZ;AAAA;AAAA;AAAA;AAGvB;;AAED,oBAAIF,gBAAJ,EAAsB;AAAA,mCAENG,kBAFM;AAClB;;AADkB,wCAEcH,gBAFd;AAAA;AAAA;AAAA;AAGrB;;AAEDhB,yBAASC,MAAT,EAAiBY,OAAjB,EAA0BC,QAA1B,EAAoCC,UAApC,EAAgDI,kBAAhD;AACH;AA5BD;;;;;AA6BH;;AAED,eAAOlB,MAAP;AACH;;AAGD,QAAI,OAAOC,GAAP,KAAe,QAAnB,EAA6B;AAAA,4BACbA,GADa,2CACMkB,SADN,EACPC,WADO,yBACMD,SADN,gBACPC,WADO,YACMD,SADN,uBACoB;AACzC;AACA,gBAAIX,qBAAJ,EAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA,gCAEML,MAFN;AAAA;AAAA;AAAA;;AAAA,yBAEcQ,QAFd,GAEwB;;AAD/C;AACAP,+BAAeD,oBAAyC,EAAEQ,UAAU,IAAZ,EAAxD;AACH,aAHD,MAGO;AACHP,+BAAeD,MAAf,CADG,CACoB;AAC1B;;AAED,gBACIiB,eACGA,YAAYC,WAAZ,KAA4BC,MAD/B,IAEG,UAAUF,WAHjB,EAIE;AACE;AACArB,yBAASC,MAAT,EAAiBmB,SAAjB,EAA4BC,YAAYlB,IAAxC,EACIkB,YAAYjB,MAAZ,IAAsBD,IAD1B,EACgCE,YADhC;AAEH,aARD,MAQO,IACHgB,eACGA,YAAYC,WAAZ,KAA4BX,KAD/B,IAEGU,YAAYG,MAFf,IAGGH,YAAY,CAAZ,EAAeC,WAAf,KAA+BC,MAHlC,IAIG,UAAUF,YAAY,CAAZ,CALV,EAML;AAAA,oCAKeA,WALf,eAK6BI,eAL7B,yBAK6BA,eAL7B,gDAKiD;AAC3CzB,6BAASC,MAAT,EAAiBmB,SAAjB,EAA4BK,gBAAgBtB,IAA5C,EACQsB,gBAAgBrB,MAAhB,IAA0BD,IADlC,EACwCE,YADxC;AAEH;AAPD;AACA;AACA;AACA;;AAKH,aAfM,MAeA;AACH;AACAL,yBAASC,MAAT,EAAiBmB,SAAjB,EAA4BC,WAA5B,EAAyClB,IAAzC,EAA+CE,YAA/C;AACH;AACJ;;AAED,eAAOJ,MAAP;AACH;;AArHqE,wBA0HlEI,YA1HkE;AAAA,8CAwHlEO,QAxHkE;AAAA,QAwHlEA,QAxHkE,yCAwHvDH,yBAAyB,KAxH8B;AAAA,8CAyHlEiB,QAzHkE;AAAA,QAyHlEA,QAzHkE,yCAyHvD,KAzHuD;;AA2HtE,QAAMC,SAASC,SAAS3B,MAAT,EAAiBE,IAAjB,CAAf;;AAEA;AACA,QAAI,CAACwB,OAAOH,MAAZ,EAAoB;AAChB,YAAIZ,QAAJ,EAAc;AACV,mBAAOX,MAAP;AACH;;AAED,cAAMS,eAAe,sBAAf,EAAuC,EAAER,QAAF,EAAOC,UAAP,EAAvC,CAAN;AACH;;AAED,QAAI,CAACuB,QAAL,EAAe;AACX,YAAMG,WAAW3B,IAAI4B,KAAJ,CAAU,GAAV,CAAjB;AACA,YAAMC,iBAAiBF,SAASL,MAAhC;;AAEA,YAAIO,iBAAiB,CAArB,EAAwB;AACpB;AACA,gBAAMC,kBAAkBC,sBAAsB;AAC1ChC,8BAD0C;AAE1C4B,kCAF0C;AAG1CF,8BAH0C;AAI1CvB,8BAJ0C;AAK1CC,0CAL0C;AAM1CL;AAN0C,aAAtB,CAAxB;;AASAkC,4BAAgBjC,MAAhB,EAAwB4B,SAASM,KAAT,CAAe,CAAf,EAAkBJ,iBAAiB,CAAnC,CAAxB,EAA+DC,eAA/D;;AAEAA;;AAEA,mBAAO/B,MAAP;AACH;AACJ;;AAED,QAAMmC,UAAUC,WAAWpC,MAAX,EAAmBC,GAAnB,CAAhB;;AAEA,QAAID,OAAOK,WAAX,EAAwB;AACpB;AADoB,sBAE2BL,MAF3B;AAAA,YAEJqC,SAFI,WAEZX,MAFY;AAAA,YAEcY,QAFd,WAEOC,KAFP;;;AAIpB,YAAI,CAACF,SAAD,IAAc,CAACC,QAAnB,EAA6B;AACzB,kBAAM7B,eAAe,gCAAf,EAAiD;AACnDiB,wBAAQW,SAD2C;AAEnDE,uBAAOD;AAF4C,aAAjD,CAAN;AAIH;;AAEDD,kBAAUpC,GAAV,IAAiBoC,UAAUpC,GAAV,KAAkBoC,UAAUpC,GAAV,EAAesB,MAAjC,GACXc,UAAUpC,GAAV,EAAeuC,GAAf,CAAmBd,MAAnB,CADW,GAEXA,MAFN;;AAIAY,iBAASrC,GAAT,IAAgBoC,UAAUpC,GAAV,EAAe,CAAf,CAAhB;AACH;;AAED;;AAjLsE,wBAkLzDyB,MAlLyD,eAkLjDe,OAlLiD,0BAkLjDA,OAlLiD;AAkLtCC,uBAAe1C,MAAf,EAAuB;AACnD0B,0BADmD;AAEnDxB,kBAAMuC,OAF6C;AAGnDxC,oBAHmD;AAInDG,sCAJmD;AAKnDD,0BALmD;AAMnDgC;AANmD,SAAvB;AAlLsC;;AA2LtE,WAAOnC,MAAP;AACH","file":"index.js","sourcesContent":["import initMK from '../_core/init';\nimport defineProp from '../_core/defineprop';\nimport getNodes from './_getnodes';\nimport createBindingSwitcher from './_createbindingswitcher';\nimport bindSingleNode from './_bindsinglenode';\nimport checkObjectType from '../_helpers/checkobjecttype';\nimport matreshkaError from '../_helpers/matreshkaerror';\nimport addTreeListener from '../on/_addtreelistener';\n\n// initializes binsing between a property of an object to HTML node\nexport default function bindNode(object, key, node, binder, eventOptions) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        eventOptions = binder;\n        binder = node;\n        node = key;\n        key = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'bindNode');\n    }\n\n    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign\n    binder = binder || {}; // eslint-disable-line no-param-reassign\n\n    initMK(object);\n\n    const { temporaryOptionalFlag } = bindNode;\n\n    delete bindNode.temporaryOptionalFlag;\n\n    // throw an error when key is falsy\n    if (!key) {\n        throw matreshkaError('binding:falsy_key');\n    }\n\n    if (key instanceof Array) {\n        if (typeof key[0] === 'string') {\n            /*\n             * accept array of keys\n             * this.bindNode(['a', 'b', 'c'], node)\n             */\n            if (temporaryOptionalFlag) {\n                // eslint-disable-next-line no-param-reassign\n                eventOptions = { ...eventOptions, optional: true };\n            }\n\n            nofn.forEach(key, itemKey => bindNode(object, itemKey, node, binder, eventOptions));\n        } else {\n            /*\n             * accept array of objects\n             * this.bindNode([{key, node, binder, event}], { silent: true });\n             */\n            nofn.forEach(key, ({\n                key: itemKey,\n                node: itemNode,\n                binder: itemBinder,\n                event: itemEventOptions\n            }) => {\n                const commonEventOptions = node;\n                const mergedEventOptions = {};\n\n                if (temporaryOptionalFlag) {\n                    mergedEventOptions.optional = true;\n                }\n\n                if (commonEventOptions) {\n                    // extend event object by \"global\" event\n                    nofn.assign(mergedEventOptions, commonEventOptions);\n                }\n\n                if (itemEventOptions) {\n                    // extend event object by \"local\" event (\"event\" key of an object)\n                    nofn.assign(mergedEventOptions, itemEventOptions);\n                }\n\n                bindNode(object, itemKey, itemNode, itemBinder, mergedEventOptions);\n            });\n        }\n\n        return object;\n    }\n\n\n    if (typeof key === 'object') {\n        nofn.forOwn(key, (keyObjValue, keyObjKey) => {\n            // binder means eventOptions\n            if (temporaryOptionalFlag) {\n                // eslint-disable-next-line no-param-reassign\n                eventOptions = binder ? { ...binder, optional: true } : { optional: true };\n            } else {\n                eventOptions = binder; // eslint-disable-line no-param-reassign\n            }\n\n            if (\n                keyObjValue\n                && keyObjValue.constructor === Object\n                && 'node' in keyObjValue\n            ) {\n                // this.bindNode({ key: { node: $(), binder } ) }, { on: 'evt' }, { silent: true });\n                bindNode(object, keyObjKey, keyObjValue.node,\n                    keyObjValue.binder || node, eventOptions);\n            } else if (\n                keyObjValue\n                && keyObjValue.constructor === Array\n                && keyObjValue.length\n                && keyObjValue[0].constructor === Object\n                && 'node' in keyObjValue[0]\n            ) {\n                // this.bindNode({ key: [{\n                //   node: $(),\n                //   binder\n                // }] ) }, { on: 'evt' }, { silent: true });\n                nofn.forEach(keyObjValue, (keyObjValueItem) => {\n                    bindNode(object, keyObjKey, keyObjValueItem.node,\n                            keyObjValueItem.binder || node, eventOptions);\n                });\n            } else {\n                // this.bindNode({ key: $() }, { on: 'evt' }, { silent: true });\n                bindNode(object, keyObjKey, keyObjValue, node, eventOptions);\n            }\n        });\n\n        return object;\n    }\n\n    const {\n        optional = temporaryOptionalFlag || false, // check out bindOptionalNode\n        exactKey = false\n    } = eventOptions;\n    const $nodes = getNodes(object, node);\n\n    // check node existence\n    if (!$nodes.length) {\n        if (optional) {\n            return object;\n        }\n\n        throw matreshkaError('binding:node_missing', { key, node });\n    }\n\n    if (!exactKey) {\n        const deepPath = key.split('.');\n        const deepPathLength = deepPath.length;\n\n        if (deepPathLength > 1) {\n            // handle binding when key arg includes dots (eg \"a.b.c.d\")\n            const bindingSwitcher = createBindingSwitcher({\n                object,\n                deepPath,\n                $nodes,\n                binder,\n                eventOptions,\n                bindNode\n            });\n\n            addTreeListener(object, deepPath.slice(0, deepPathLength - 1), bindingSwitcher);\n\n            bindingSwitcher();\n\n            return object;\n        }\n    }\n\n    const propDef = defineProp(object, key);\n\n    if (object.isMatreshka) {\n        // if an object is Matreshka instance then extend \"$nodes\" and \"nodes\" objects\n        const { $nodes: $allNodes, nodes: allNodes } = object;\n\n        if (!$allNodes || !allNodes) {\n            throw matreshkaError('binding:instance_nodes_missing', {\n                $nodes: $allNodes,\n                nodes: allNodes\n            });\n        }\n\n        $allNodes[key] = $allNodes[key] && $allNodes[key].length\n            ? $allNodes[key].add($nodes)\n            : $nodes;\n\n        allNodes[key] = $allNodes[key][0];\n    }\n\n    // handle binding for every node separately\n    nofn.forEach($nodes, oneNode => bindSingleNode(object, {\n        $nodes,\n        node: oneNode,\n        key,\n        eventOptions,\n        binder,\n        propDef\n    }));\n\n    return object;\n}\n"]}