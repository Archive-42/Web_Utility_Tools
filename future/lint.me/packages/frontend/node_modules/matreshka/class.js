'use strict';

// static methods and properties of classes will be hidden under Symbol('staticNames')
var staticNamesProperty = typeof Symbol === 'function' ? Symbol('staticNames') : '__staticNames';
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
module.exports = Class;
function Class(prototype, staticProps) {
    var Constructor = hasOwnProperty.call(prototype, 'constructor') ? prototype.constructor : function EmptyConstructor() {};
    // extends is kept for backward compatibility
    var Parent = prototype.extends;
    // inherit proto from class parent or empty object
    var proto = Object.create(Parent ? Parent.prototype : {});
    var parentStaticNames = Parent ? Parent[staticNamesProperty] : undefined;

    // allow to pass symbols as prototype properties
    var _result = proto;

    for (var _source2 = prototype, _keys4 = Object.keys(_source2), _l7 = _keys4.length, _i4 = 0, _key2; _i4 < _l7; _i4++) {
        _key2 = _keys4[_i4];
        _result[_key2] = _source2[_key2];
    }

    if (getOwnPropertySymbols) {
        var symbols = getOwnPropertySymbols(prototype);

        for (var _target = symbols, _index = 0, symbol, _l2 = _target.length; symbol = _target[_index], _index < _l2; _index++) {
            proto[symbol] = prototype[symbol];
        }
    }

    // inherit staric properties of a parent
    if (typeof parentStaticNames === 'object') {
        (function () {
            var staticNames = Constructor[staticNamesProperty] || {};
            Constructor[staticNamesProperty] = staticNames;

            // inherit static properties of a parent when their keys are symbols
            for (var _target2 = parentStaticNames, _keys2 = Object.keys(_target2), _i2 = 0, name, _, _l3 = _keys2.length; (name = _keys2[_i2], _ = _target2[name]), _i2 < _l3; _i2++) {
                Constructor[name] = Parent[name];
                staticNames[name] = true;
            }

            if (getOwnPropertySymbols) {
                var _symbols = getOwnPropertySymbols(parentStaticNames);

                for (var _target3 = _symbols, _index2 = 0, symbol, _l4 = _target3.length; symbol = _target3[_index2], _index2 < _l4; _index2++) {
                    Constructor[symbol] = Parent[symbol];
                    staticNames[symbol] = true;
                }
            }
        })();
    }

    // extend Constructor with passed static properties
    if (typeof staticProps === 'object') {
        (function () {
            var staticNames = Constructor[staticNamesProperty] || {};
            Constructor[staticNamesProperty] = staticNames;

            // extend Constructor with passed static properties if their keys are symbols
            for (var _target4 = staticProps, _keys3 = Object.keys(_target4), _i3 = 0, key, value, _l5 = _keys3.length; (key = _keys3[_i3], value = _target4[key]), _i3 < _l5; _i3++) {
                Constructor[key] = value;
                staticNames[key] = true;
            }

            if (getOwnPropertySymbols) {
                var _symbols2 = getOwnPropertySymbols(staticProps);

                for (var _target5 = _symbols2, _index3 = 0, symbol, _l6 = _target5.length; symbol = _target5[_index3], _index3 < _l6; _index3++) {
                    Constructor[symbol] = staticProps[symbol];
                    staticNames[symbol] = true;
                }
            }
        })();
    }

    Constructor.prototype = proto;

    // if new Class({}) is called return its instance
    if (this instanceof Class) {
        return new Constructor();
    }

    return Constructor;
}
//# sourceMappingURL=class.js.map