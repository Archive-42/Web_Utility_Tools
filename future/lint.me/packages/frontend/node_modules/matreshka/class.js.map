{"version":3,"sources":["../src/class.js"],"names":["staticNamesProperty","Symbol","getOwnPropertySymbols","Object","hasOwnProperty","prototype","Class","staticProps","Constructor","call","constructor","EmptyConstructor","Parent","extends","proto","create","parentStaticNames","undefined","symbols","symbol","staticNames","name","_","key","value"],"mappings":";;AAAA;AACA,IAAMA,sBAAsB,OAAOC,MAAP,KAAkB,UAAlB,GAA+BA,OAAO,aAAP,CAA/B,GAAuD,eAAnF;IACQC,qB,GAA0BC,M,CAA1BD,qB;IACAE,c,GAAmBD,OAAOE,S,CAA1BD,c;iBAEgBE,K;AAAT,SAASA,KAAT,CAAeD,SAAf,EAA0BE,WAA1B,EAAuC;AAClD,QAAMC,cAAcJ,eAAeK,IAAf,CAAoBJ,SAApB,EAA+B,aAA/B,IACdA,UAAUK,WADI,GAEd,SAASC,gBAAT,GAA4B,CAAE,CAFpC;AAGA;AACA,QAAMC,SAASP,UAAUQ,OAAzB;AACA;AACA,QAAMC,QAAQX,OAAOY,MAAP,CAAcH,SAASA,OAAOP,SAAhB,GAA4B,EAA1C,CAAd;AACA,QAAMW,oBAAoBJ,SAASA,OAAOZ,mBAAP,CAAT,GAAuCiB,SAAjE;;AAIA;AAZkD,kBAUtCH,KAVsC;;AAAA,wBAU/BT,SAV+B;AAAA;AAAA;AAAA;;AAalD,QAAIH,qBAAJ,EAA2B;AACvB,YAAMgB,UAAUhB,sBAAsBG,SAAtB,CAAhB;;AADuB,2BAEVa,OAFU,cAEAC,MAFA,wBAEAA,MAFA,4CAEW;AAC9BL,kBAAMK,MAAN,IAAgBd,UAAUc,MAAV,CAAhB;AACH;AACJ;;AAED;AACA,QAAI,OAAOH,iBAAP,KAA6B,QAAjC,EAA2C;AAAA;AACvC,gBAAMI,cAAcZ,YAAYR,mBAAZ,KAAoC,EAAxD;AACAQ,wBAAYR,mBAAZ,IAAmCoB,WAAnC;;AAOA;AATuC,gCAI3BJ,iBAJ2B,2CAIJK,IAJI,EAIPC,CAJO,wBAIJD,IAJI,gBAIPC,CAJO,YAIJD,IAJI,sBAIK;AACxCb,4BAAYa,IAAZ,IAAoBT,OAAOS,IAAP,CAApB;AACAD,4BAAYC,IAAZ,IAAoB,IAApB;AACH;;AAGD,gBAAInB,qBAAJ,EAA2B;AACvB,oBAAMgB,WAAUhB,sBAAsBc,iBAAtB,CAAhB;;AADuB,oCAEVE,QAFU,eAEAC,MAFA,yBAEAA,MAFA,gDAEW;AAC9BX,gCAAYW,MAAZ,IAAsBP,OAAOO,MAAP,CAAtB;AACAC,gCAAYD,MAAZ,IAAsB,IAAtB;AACH;AACJ;AAhBsC;AAiB1C;;AAED;AACA,QAAI,OAAOZ,WAAP,KAAuB,QAA3B,EAAqC;AAAA;AACjC,gBAAMa,cAAcZ,YAAYR,mBAAZ,KAAoC,EAAxD;AACAQ,wBAAYR,mBAAZ,IAAmCoB,WAAnC;;AAOA;AATiC,gCAIrBb,WAJqB,2CAIAgB,GAJA,EAIPC,KAJO,wBAIAD,GAJA,gBAIPC,KAJO,YAIAD,GAJA,sBAIQ;AACrCf,4BAAYe,GAAZ,IAAmBC,KAAnB;AACAJ,4BAAYG,GAAZ,IAAmB,IAAnB;AACH;;AAGD,gBAAIrB,qBAAJ,EAA2B;AACvB,oBAAMgB,YAAUhB,sBAAsBK,WAAtB,CAAhB;;AADuB,oCAEVW,SAFU,eAEAC,MAFA,yBAEAA,MAFA,gDAEW;AAC9BX,gCAAYW,MAAZ,IAAsBZ,YAAYY,MAAZ,CAAtB;AACAC,gCAAYD,MAAZ,IAAsB,IAAtB;AACH;AACJ;AAhBgC;AAiBpC;;AAEDX,gBAAYH,SAAZ,GAAwBS,KAAxB;;AAEA;AACA,QAAI,gBAAgBR,KAApB,EAA2B;AACvB,eAAO,IAAIE,WAAJ,EAAP;AACH;;AAED,WAAOA,WAAP;AACH","file":"class.js","sourcesContent":["// static methods and properties of classes will be hidden under Symbol('staticNames')\nconst staticNamesProperty = typeof Symbol === 'function' ? Symbol('staticNames') : '__staticNames';\nconst { getOwnPropertySymbols } = Object;\nconst { hasOwnProperty } = Object.prototype;\n\nexport default function Class(prototype, staticProps) {\n    const Constructor = hasOwnProperty.call(prototype, 'constructor')\n        ? prototype.constructor\n        : function EmptyConstructor() {};\n    // extends is kept for backward compatibility\n    const Parent = prototype.extends;\n    // inherit proto from class parent or empty object\n    const proto = Object.create(Parent ? Parent.prototype : {});\n    const parentStaticNames = Parent ? Parent[staticNamesProperty] : undefined;\n\n    nofn.assign(proto, prototype);\n\n    // allow to pass symbols as prototype properties\n    if (getOwnPropertySymbols) {\n        const symbols = getOwnPropertySymbols(prototype);\n        nofn.forEach(symbols, (symbol) => {\n            proto[symbol] = prototype[symbol];\n        });\n    }\n\n    // inherit staric properties of a parent\n    if (typeof parentStaticNames === 'object') {\n        const staticNames = Constructor[staticNamesProperty] || {};\n        Constructor[staticNamesProperty] = staticNames;\n\n        nofn.forOwn(parentStaticNames, (_, name) => {\n            Constructor[name] = Parent[name];\n            staticNames[name] = true;\n        });\n\n        // inherit static properties of a parent when their keys are symbols\n        if (getOwnPropertySymbols) {\n            const symbols = getOwnPropertySymbols(parentStaticNames);\n            nofn.forEach(symbols, (symbol) => {\n                Constructor[symbol] = Parent[symbol];\n                staticNames[symbol] = true;\n            });\n        }\n    }\n\n    // extend Constructor with passed static properties\n    if (typeof staticProps === 'object') {\n        const staticNames = Constructor[staticNamesProperty] || {};\n        Constructor[staticNamesProperty] = staticNames;\n\n        nofn.forOwn(staticProps, (value, key) => {\n            Constructor[key] = value;\n            staticNames[key] = true;\n        });\n\n        // extend Constructor with passed static properties if their keys are symbols\n        if (getOwnPropertySymbols) {\n            const symbols = getOwnPropertySymbols(staticProps);\n            nofn.forEach(symbols, (symbol) => {\n                Constructor[symbol] = staticProps[symbol];\n                staticNames[symbol] = true;\n            });\n        }\n    }\n\n    Constructor.prototype = proto;\n\n    // if new Class({}) is called return its instance\n    if (this instanceof Class) {\n        return new Constructor();\n    }\n\n    return Constructor;\n}\n"]}