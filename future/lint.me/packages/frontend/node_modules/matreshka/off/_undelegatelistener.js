'use strict';

var defs = require('../_core/defs');

var removeListener = require('./_removelistener');

// the function removes internally used events such as _asterisk:add
function detatchDelegatedLogic(_ref) {
    var delegatedEventName = _ref.delegatedEventName,
        pathStr = _ref.pathStr,
        allEvents = _ref.allEvents;

    var retain = [];
    var events = allEvents[delegatedEventName];

    for (var _target = events, _index = 0, event, _l = _target.length; event = _target[_index], _index < _l; _index++) {
        // pathStr is assigned to info in delegateListener
        if (event.info.pathStr !== pathStr) {
            retain.push(event);
        }
    }

    if (retain.length) {
        allEvents[delegatedEventName] = retain;
    } else {
        delete allEvents[delegatedEventName];
    }
}

// removes delegated event listener from an object by given path
module.exports = undelegateListener;
function undelegateListener(object, givenPath, name, callback, context) {
    var info = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

    var def = defs.get(object);

    // if no definition do nothing
    if (!def) {
        return;
    }

    var allEvents = def.events;


    var path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;

    if (!path || !path.length) {
        // if no path then remove listener
        removeListener(object, name, callback, context, info);
    } else {
        // else do all magic
        var key = path[0];
        var pathStr = void 0;

        if (path.length > 1) {
            var _source = path,
                _l2 = _source.length,
                _i = 1 || 0,
                _end = null || _l2,
                _j = 0,
                _result = Array(_end - _i);

            while (_i < _end) {
                _result[_j++] = _source[_i++];
            }

            path = _result;
            pathStr = path.join('.');
        } else {
            path = [];
            pathStr = path[0] || '';
        }

        if (key === '*') {
            // remove asterisk events
            if (object.isMatreshkaArray) {
                var delegatedAddEvtName = '_asterisk:add';
                if (allEvents[delegatedAddEvtName]) {
                    detatchDelegatedLogic({
                        delegatedEventName: delegatedAddEvtName,
                        pathStr: pathStr,
                        allEvents: allEvents
                    });
                }

                var delegatedRemoveEvtName = '_asterisk:remove';
                if (allEvents[delegatedRemoveEvtName]) {
                    detatchDelegatedLogic({
                        delegatedEventName: delegatedRemoveEvtName,
                        pathStr: pathStr,
                        allEvents: allEvents
                    });
                }

                // undelegate asterisk events for existing items
                if (object.length) {
                    for (var _target2 = object, _index2 = 0, item, _l3 = _target2.length; item = _target2[_index2], _index2 < _l3; _index2++) {
                        if (item && typeof item === 'object') {
                            undelegateListener(item, path, name, callback, context, info);
                        }
                    }
                }
            } else if (object.isMatreshkaObject) {
                var delegatedSetEvtName = '_asterisk:set';
                if (allEvents[delegatedSetEvtName]) {
                    detatchDelegatedLogic({
                        delegatedEventName: delegatedSetEvtName,
                        pathStr: pathStr,
                        allEvents: allEvents
                    });
                }

                var _delegatedRemoveEvtName = '_asterisk:remove';
                if (allEvents[_delegatedRemoveEvtName]) {
                    detatchDelegatedLogic({
                        delegatedEventName: _delegatedRemoveEvtName,
                        pathStr: pathStr,
                        allEvents: allEvents
                    });
                }

                object.each(function (item) {
                    if (item && typeof item === 'object') {
                        undelegateListener(item, path, name, callback, context, info);
                    }
                });
            }
        } else {
            // remove non-asterisk delegated events

            var delegatedChangeEvtName = '_change:delegated:' + key;
            if (allEvents[delegatedChangeEvtName]) {
                detatchDelegatedLogic({
                    delegatedEventName: delegatedChangeEvtName,
                    pathStr: pathStr,
                    allEvents: allEvents
                });
            }

            if (typeof object[key] === 'object') {
                undelegateListener(object[key], path, name, callback, context, info);
            }
        }
    }
}
//# sourceMappingURL=_undelegatelistener.js.map