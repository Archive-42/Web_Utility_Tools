{"version":3,"sources":["../../src/off/_undelegatelistener.js"],"names":["detatchDelegatedLogic","delegatedEventName","pathStr","allEvents","retain","events","event","info","push","length","undelegateListener","object","givenPath","name","callback","context","def","defs","get","path","split","removeListener","key","join","isMatreshkaArray","delegatedAddEvtName","delegatedRemoveEvtName","item","isMatreshkaObject","delegatedSetEvtName","each","delegatedChangeEvtName"],"mappings":";;mBAAiB,e;;6BACU,mB;;AAE3B;AACA,SAASA,qBAAT,OAIG;AAAA,QAHCC,kBAGD,QAHCA,kBAGD;AAAA,QAFCC,OAED,QAFCA,OAED;AAAA,QADCC,SACD,QADCA,SACD;;AACC,QAAMC,SAAS,EAAf;AACA,QAAMC,SAASF,UAAUF,kBAAV,CAAf;;AAFD,uBAIcI,MAJd,cAIuBC,KAJvB,uBAIuBA,KAJvB,2CAIiC;AAC5B;AACA,YAAIA,MAAMC,IAAN,CAAWL,OAAX,KAAuBA,OAA3B,EAAoC;AAChCE,mBAAOI,IAAP,CAAYF,KAAZ;AACH;AACJ;;AAED,QAAIF,OAAOK,MAAX,EAAmB;AACfN,kBAAUF,kBAAV,IAAgCG,MAAhC;AACH,KAFD,MAEO;AACH,eAAOD,UAAUF,kBAAV,CAAP;AACH;AACJ;;AAED;iBACwBS,kB;AAAT,SAASA,kBAAT,CAA4BC,MAA5B,EAAoCC,SAApC,EAA+CC,IAA/C,EAAqDC,QAArD,EAA+DC,OAA/D,EAAmF;AAAA,QAAXR,IAAW,uEAAJ,EAAI;;AAC9F,QAAMS,MAAMC,KAAKC,GAAL,CAASP,MAAT,CAAZ;;AAEA;AACA,QAAI,CAACK,GAAL,EAAU;AACN;AACH;;AAN6F,QAQ9Eb,SAR8E,GAQhEa,GARgE,CAQtFX,MARsF;;;AAU9F,QAAIc,OAAO,OAAOP,SAAP,KAAqB,QAArB,IAAiCA,cAAc,EAA/C,GAAoDA,UAAUQ,KAAV,CAAgB,GAAhB,CAApD,GAA2ER,SAAtF;;AAEA,QAAI,CAACO,IAAD,IAAS,CAACA,KAAKV,MAAnB,EAA2B;AACvB;AACAY,uBAAeV,MAAf,EAAuBE,IAAvB,EAA6BC,QAA7B,EAAuCC,OAAvC,EAAgDR,IAAhD;AACH,KAHD,MAGO;AACH;AACA,YAAMe,MAAMH,KAAK,CAAL,CAAZ;AACA,YAAIjB,gBAAJ;;AAEA,YAAIiB,KAAKV,MAAL,GAAc,CAAlB,EAAqB;AAAA,0BACCU,IADD;AAAA;AAAA,qBACO,CADP;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACjBA;AACAjB,sBAAUiB,KAAKI,IAAL,CAAU,GAAV,CAAV;AACH,SAHD,MAGO;AACHJ,mBAAO,EAAP;AACAjB,sBAAUiB,KAAK,CAAL,KAAW,EAArB;AACH;;AAED,YAAIG,QAAQ,GAAZ,EAAiB;AACb;AACA,gBAAIX,OAAOa,gBAAX,EAA6B;AACzB,oBAAMC,sBAAsB,eAA5B;AACA,oBAAItB,UAAUsB,mBAAV,CAAJ,EAAoC;AAChCzB,0CAAsB;AAClBC,4CAAoBwB,mBADF;AAElBvB,wCAFkB;AAGlBC;AAHkB,qBAAtB;AAKH;;AAED,oBAAMuB,yBAAyB,kBAA/B;AACA,oBAAIvB,UAAUuB,sBAAV,CAAJ,EAAuC;AACnC1B,0CAAsB;AAClBC,4CAAoByB,sBADF;AAElBxB,wCAFkB;AAGlBC;AAHkB,qBAAtB;AAKH;;AAED;AACA,oBAAIQ,OAAOF,MAAX,EAAmB;AAAA,wCACFE,MADE,eACOgB,IADP,yBACOA,IADP,gDACgB;AAC3B,4BAAIA,QAAQ,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AAClCjB,+CAAmBiB,IAAnB,EAAyBR,IAAzB,EAA+BN,IAA/B,EAAqCC,QAArC,EAA+CC,OAA/C,EAAwDR,IAAxD;AACH;AACJ;AACJ;AACJ,aA3BD,MA2BO,IAAII,OAAOiB,iBAAX,EAA8B;AACjC,oBAAMC,sBAAsB,eAA5B;AACA,oBAAI1B,UAAU0B,mBAAV,CAAJ,EAAoC;AAChC7B,0CAAsB;AAClBC,4CAAoB4B,mBADF;AAElB3B,wCAFkB;AAGlBC;AAHkB,qBAAtB;AAKH;;AAED,oBAAMuB,0BAAyB,kBAA/B;AACA,oBAAIvB,UAAUuB,uBAAV,CAAJ,EAAuC;AACnC1B,0CAAsB;AAClBC,4CAAoByB,uBADF;AAElBxB,wCAFkB;AAGlBC;AAHkB,qBAAtB;AAKH;;AAEDQ,uBAAOmB,IAAP,CAAY,UAACH,IAAD,EAAU;AAClB,wBAAIA,QAAQ,OAAOA,IAAP,KAAgB,QAA5B,EAAsC;AAClCjB,2CAAmBiB,IAAnB,EAAyBR,IAAzB,EAA+BN,IAA/B,EAAqCC,QAArC,EAA+CC,OAA/C,EAAwDR,IAAxD;AACH;AACJ,iBAJD;AAKH;AACJ,SAtDD,MAsDO;AACH;;AAEA,gBAAMwB,gDAA8CT,GAApD;AACA,gBAAInB,UAAU4B,sBAAV,CAAJ,EAAuC;AACnC/B,sCAAsB;AAClBC,wCAAoB8B,sBADF;AAElB7B,oCAFkB;AAGlBC;AAHkB,iBAAtB;AAKH;;AAED,gBAAI,OAAOQ,OAAOW,GAAP,CAAP,KAAuB,QAA3B,EAAqC;AACjCZ,mCAAmBC,OAAOW,GAAP,CAAnB,EAAgCH,IAAhC,EAAsCN,IAAtC,EAA4CC,QAA5C,EAAsDC,OAAtD,EAA+DR,IAA/D;AACH;AACJ;AACJ;AACJ","file":"_undelegatelistener.js","sourcesContent":["import defs from '../_core/defs';\nimport removeListener from './_removelistener';\n\n// the function removes internally used events such as _asterisk:add\nfunction detatchDelegatedLogic({\n    delegatedEventName,\n    pathStr,\n    allEvents\n}) {\n    const retain = [];\n    const events = allEvents[delegatedEventName];\n\n    nofn.forEach(events, (event) => {\n        // pathStr is assigned to info in delegateListener\n        if (event.info.pathStr !== pathStr) {\n            retain.push(event);\n        }\n    });\n\n    if (retain.length) {\n        allEvents[delegatedEventName] = retain;\n    } else {\n        delete allEvents[delegatedEventName];\n    }\n}\n\n// removes delegated event listener from an object by given path\nexport default function undelegateListener(object, givenPath, name, callback, context, info = {}) {\n    const def = defs.get(object);\n\n    // if no definition do nothing\n    if (!def) {\n        return;\n    }\n\n    const { events: allEvents } = def;\n\n    let path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;\n\n    if (!path || !path.length) {\n        // if no path then remove listener\n        removeListener(object, name, callback, context, info);\n    } else {\n        // else do all magic\n        const key = path[0];\n        let pathStr;\n\n        if (path.length > 1) {\n            path = nofn.slice(path, 1);\n            pathStr = path.join('.');\n        } else {\n            path = [];\n            pathStr = path[0] || '';\n        }\n\n        if (key === '*') {\n            // remove asterisk events\n            if (object.isMatreshkaArray) {\n                const delegatedAddEvtName = '_asterisk:add';\n                if (allEvents[delegatedAddEvtName]) {\n                    detatchDelegatedLogic({\n                        delegatedEventName: delegatedAddEvtName,\n                        pathStr,\n                        allEvents\n                    });\n                }\n\n                const delegatedRemoveEvtName = '_asterisk:remove';\n                if (allEvents[delegatedRemoveEvtName]) {\n                    detatchDelegatedLogic({\n                        delegatedEventName: delegatedRemoveEvtName,\n                        pathStr,\n                        allEvents\n                    });\n                }\n\n                // undelegate asterisk events for existing items\n                if (object.length) {\n                    nofn.forEach(object, (item) => {\n                        if (item && typeof item === 'object') {\n                            undelegateListener(item, path, name, callback, context, info);\n                        }\n                    });\n                }\n            } else if (object.isMatreshkaObject) {\n                const delegatedSetEvtName = '_asterisk:set';\n                if (allEvents[delegatedSetEvtName]) {\n                    detatchDelegatedLogic({\n                        delegatedEventName: delegatedSetEvtName,\n                        pathStr,\n                        allEvents\n                    });\n                }\n\n                const delegatedRemoveEvtName = '_asterisk:remove';\n                if (allEvents[delegatedRemoveEvtName]) {\n                    detatchDelegatedLogic({\n                        delegatedEventName: delegatedRemoveEvtName,\n                        pathStr,\n                        allEvents\n                    });\n                }\n\n                object.each((item) => {\n                    if (item && typeof item === 'object') {\n                        undelegateListener(item, path, name, callback, context, info);\n                    }\n                });\n            }\n        } else {\n            // remove non-asterisk delegated events\n\n            const delegatedChangeEvtName = `_change:delegated:${key}`;\n            if (allEvents[delegatedChangeEvtName]) {\n                detatchDelegatedLogic({\n                    delegatedEventName: delegatedChangeEvtName,\n                    pathStr,\n                    allEvents\n                });\n            }\n\n            if (typeof object[key] === 'object') {\n                undelegateListener(object[key], path, name, callback, context, info);\n            }\n        }\n    }\n}\n"]}