'use strict';

var splitBySpaceReg = require('../on/_splitbyspaceregexp');

var checkObjectType = require('../_helpers/checkobjecttype');

var defs = require('../_core/defs');

var removeListener = require('./_removelistener');

var undelegateListener = require('./_undelegatelistener');

var dom = require('../_dom');

// removes event listener
module.exports = off;
function off(object, givenNames, callback, context) {
    if (typeof this === 'object' && this.isMatreshka) {
        // when context is Matreshka instance, use this as an object and shift other args
        /* eslint-disable no-param-reassign */
        context = callback;
        callback = givenNames;
        givenNames = object;
        object = this;
        /* eslint-enable no-param-reassign */
    } else {
        // throw error when object type is wrong
        checkObjectType(object, 'off');
    }

    var isNamesVarArray = givenNames instanceof Array;
    var def = defs.get(object);

    // allow to pass name-handler object
    // TODO: Name-handler object passed to off method is non-documented feature
    if (givenNames && typeof givenNames === 'object' && !isNamesVarArray) {
        for (var _target = givenNames, _keys = Object.keys(_target), _i = 0, namesObjName, namesObjCallback, _l = _keys.length; (namesObjName = _keys[_i], namesObjCallback = _target[namesObjName]), _i < _l; _i++) {
            off(object, namesObjName, namesObjCallback, callback)
        }

        return object;
    }

    if (!givenNames && !callback && !context) {
        def.events = {};

        for (var _target3 = def.props, _keys2 = Object.keys(_target3), _i2 = 0, propName, _ref, _l3 = _keys2.length; (propName = _keys2[_i2], _ref = _target3[propName]), _i2 < _l3; _i2++) {
            var bindings = _ref.bindings;

            if (bindings) {
                for (var _target2 = bindings, _index = 0, _ref2, _l2 = _target2.length; _ref2 = _target2[_index], _index < _l2; _index++) {
                    var node = _ref2.node;

                    var eventNamespace = def.id + propName;
                    dom.$(node).off('.' + eventNamespace);
                }
            }
        }

        return object;
    }

    // TODO: Array of names passed to off method is non-documented feature
    // split by spaces
    var names = isNamesVarArray ? givenNames : givenNames.split(splitBySpaceReg);

    for (var _target4 = names, _index2 = 0, name, _l4 = _target4.length; name = _target4[_index2], _index2 < _l4; _index2++) {
        var delegatedEventParts = name.split('@');
        if (delegatedEventParts.length > 1) {
            var path = delegatedEventParts[0],
                delegatedName = delegatedEventParts[1];

            undelegateListener(object, path, delegatedName, callback, context);
        } else {
            removeListener(object, name, callback, context);
        }
    }

    return object;
}
//# sourceMappingURL=index.js.map