'use strict';

var initMK = require('../_core/init');

var triggerOne = require('../trigger/_triggerone');

var defineProp = require('../_core/defineprop');

var domEventReg = require('./_domeventregexp');

// property modifier event regexp
var propModEventReg // eslint-disable-next-line max-len
= /^_change:deps:|^_change:bindings:|^_change:delegated:|^_change:common:|^_change:tree:|^change:|^beforechange:/;

// adds simple event listener
// used as core of event engine
module.exports = addListener;
function addListener(object, name, callback, context) {
    var info = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    var _initMK = initMK(object),
        allEvents = _initMK.events;

    var ctx = context || object;
    var events = allEvents[name];
    var event = { callback: callback, context: context, ctx: ctx, name: name, info: info };
    // skipChecks is used by internal methods for better performance
    var _info$skipChecks = info.skipChecks,
        skipChecks = _info$skipChecks === undefined ? false : _info$skipChecks;


    if (!skipChecks) {
        var domEventExecResult = domEventReg.exec(name);

        if (domEventExecResult) {
            var eventName = domEventExecResult[1],
                _domEventExecResult$ = domEventExecResult[2],
                key = _domEventExecResult$ === undefined ? 'sandbox' : _domEventExecResult$,
                selector = domEventExecResult[3];
            // fixing circular reference issue

            var addDomListener = require('./_adddomlistener');

            addDomListener(object, key, eventName, selector, callback, context, info);

            return true;
        }
    }

    // if there are events with the same name
    if (events) {
        if (!skipChecks) {
            // if there are events with the same data, return false
            for (var i = 0; i < events.length; i++) {
                var existingEvent = events[i];
                var argCallback = callback && callback._callback || callback;
                var eventCallback = existingEvent.callback._callback || existingEvent.callback;
                if (argCallback === eventCallback && existingEvent.context === context) {
                    return false;
                }
            }
        }

        // if the event isn't found add it to the event list
        events.push(event);
    } else {
        // if there are no events with the same name, create an array with only  one event
        allEvents[name] = [event];
    }

    if (propModEventReg.test(name)) {
        // define needed accessors for KEY
        defineProp(object, name.replace(propModEventReg, ''));
    }

    // names prefixed by underscore mean "private" events
    if (!skipChecks && name[0] !== '_') {
        triggerOne(object, 'addevent:' + name, event);
        triggerOne(object, 'addevent', event);
    }

    // if event is added successfully return true
    return true;
}
//# sourceMappingURL=_addlistener.js.map