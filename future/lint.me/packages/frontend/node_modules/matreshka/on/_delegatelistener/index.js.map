{"version":3,"sources":["../../../src/on/_delegatelistener/index.js"],"names":["delegateListener","object","givenPath","name","callback","context","info","path","split","length","addListener","key","pathStr","join","delegatedData","isMatreshkaArray","arrayAddHandler","skipChecks","arrayRemoveHandler","added","isMatreshkaObject","def","defs","get","objectSetHandler","objectRemoveHandler","keys","defKey","_","item","changeHandler","value"],"mappings":"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","file":"index.js","sourcesContent":["import addListener from '../_addlistener';\nimport defs from '../../_core/defs';\nimport arrayAddHandler from './arrayaddhandler';\nimport objectSetHandler from './objectsethandler';\nimport arrayRemoveHandler from './arrayremovehandler';\nimport objectRemoveHandler from './objectremovehandler';\nimport changeHandler from './changehandler';\n\n// adds delegated event listener to an object by given path\nexport default function delegateListener(object, givenPath, name, callback, context, info = {}) {\n    // if typeof path is string and path is not empty string then split it\n    let path = typeof givenPath === 'string' && givenPath !== '' ? givenPath.split('.') : givenPath;\n\n    if (!path || !path.length) {\n        // if no path then add simple listener\n        addListener(object, name, callback, context, info);\n    } else {\n        // else do all magic\n        const key = path[0];\n        let pathStr; // needed for undelegation\n\n        if (path.length > 1) {\n            path = nofn.slice(path, 1);\n            pathStr = path.join('.');\n        } else {\n            path = [];\n            pathStr = path[0] || '';\n        }\n\n        const delegatedData = {\n            path,\n            name,\n            callback,\n            context,\n            info,\n            object\n        };\n\n        if (key === '*') {\n            // handling asterisk events\n            // { skipChecks: true } allows to use same event name and event handler few times\n            if (object.isMatreshkaArray) {\n                // the event is triggered when something is added to an array\n                addListener(object, '_asterisk:add', arrayAddHandler, null, {\n                    delegatedData,\n                    pathStr,\n                    skipChecks: true\n                });\n\n                // the event is triggered when something is removed from an array\n                addListener(object, '_asterisk:remove', arrayRemoveHandler, null, {\n                    delegatedData,\n                    pathStr,\n                    skipChecks: true\n                });\n\n                // call handler manually to delegate listener for currently existing data props\n                arrayAddHandler({\n                    added: object\n                }, delegatedData);\n            } else if (object.isMatreshkaObject) {\n                const def = defs.get(object);\n\n                // the event is triggered when data prop is changed\n                addListener(object, '_asterisk:set', objectSetHandler, null, {\n                    delegatedData,\n                    pathStr,\n                    skipChecks: true\n                });\n\n                // the event is triggered when data prop is removed\n                addListener(object, '_asterisk:remove', objectRemoveHandler, null, {\n                    delegatedData,\n                    pathStr,\n                    skipChecks: true\n                });\n\n                // delegate listener for currently existing data props\n                nofn.forOwn(def.keys, (_, defKey) => {\n                    const item = object[defKey];\n                    if (item && typeof item === 'object') {\n                        delegateListener(item, path, name, callback, context, info);\n                    }\n                });\n            }\n        } else {\n            // handling non-asterisk delegated event\n\n            // the event is triggered by \"set\"\n            addListener(object, `_change:delegated:${key}`, changeHandler, null, {\n                delegatedData,\n                pathStr\n            });\n\n            // call handler manually\n            changeHandler({\n                value: object[key]\n            }, delegatedData);\n        }\n    }\n}\n"]}