'use strict';

var splitBySpaceReg = require('./_splitbyspaceregexp');

var checkObjectType = require('../_helpers/checkobjecttype');

var matreshkaError = require('../_helpers/matreshkaerror');

var addListener = require('./_addlistener');

var delegateListener = require('./_delegatelistener');

// adds event listener
module.exports = on;
function on(object, givenNames, callback, triggerOnInit, context) {
    if (typeof this === 'object' && this.isMatreshka) {
        // when context is Matreshka instance, use this as an object and shift other args
        /* eslint-disable no-param-reassign */
        context = triggerOnInit;
        triggerOnInit = callback;
        callback = givenNames;
        givenNames = object;
        object = this;
        /* eslint-enable no-param-reassign */
    } else {
        // throw error when object type is wrong
        checkObjectType(object, 'on');
    }

    var isNamesVarArray = givenNames instanceof Array;

    // allow to pass name-handler object
    if (givenNames && typeof givenNames === 'object' && !isNamesVarArray) {
        for (var _target = givenNames, _keys = Object.keys(_target), _i = 0, namesObjName, namesObjCallback, _l = _keys.length; (namesObjName = _keys[_i], namesObjCallback = _target[namesObjName]), _i < _l; _i++) {
            on(object, namesObjName, namesObjCallback, callback, triggerOnInit)
        }

        return object;
    }

    if (typeof givenNames !== 'string' && !isNamesVarArray) {
        throw matreshkaError('on:names_type', { names: givenNames });
    }

    // split by spaces
    // TODO: Array of names passed to on method is non-documented feature
    var names = isNamesVarArray ? givenNames : givenNames.split(splitBySpaceReg);

    // flip triggerOnInit and context when triggerOnInit is not boolean
    if (typeof triggerOnInit !== 'boolean' && typeof triggerOnInit !== 'undefined') {
        var _ref = [triggerOnInit, context];
        // eslint-disable-next-line no-param-reassign

        context = _ref[0];
        triggerOnInit = _ref[1];
    }

    // call callback immediatelly if triggerOnInit is true
    for (var _target2 = names, _index = 0, name, _l2 = _target2.length; name = _target2[_index], _index < _l2; _index++) {
        var delegatedEventParts = name.split('@');

        if (delegatedEventParts.length > 1) {
            // if @ exists in event name then this is delegated event
            var path = delegatedEventParts[0],
                delegatedName = delegatedEventParts[1];

            delegateListener(object, path, delegatedName, callback, context || object);
        } else {
            // if not, this is simple event
            addListener(object, name, callback, context);
        }
    }

    if (triggerOnInit === true) {
        callback.call(context || object, { triggerOnInit: triggerOnInit });
    }

    return object;
}
//# sourceMappingURL=index.js.map