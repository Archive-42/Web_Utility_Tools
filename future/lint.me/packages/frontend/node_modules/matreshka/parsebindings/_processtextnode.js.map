{"version":3,"sources":["../../src/parsebindings/_processtextnode.js"],"names":["textNodeBinder","setValue","value","textContent","processTextNode","object","node","textNode","eventOptions","bindingReg","parserData","window","document","lastIndex","tokens","split","fragment","createDocumentFragment","index","token","newTextNode","createTextNode","appendChild","bindNode","insertBefore","removeChild"],"mappings":";;yBAAuB,e;;uBACF,a;;AAErB,IAAMA,iBAAiB;AACnBC,YADmB,YACVC,KADU,EACH;AACZ,aAAKC,WAAL,GAAmB,OAAOD,KAAP,KAAiB,WAAjB,GAA+B,EAA/B,GAAoCA,KAAvD;AACH;AAHkB,CAAvB;;AAMA;AACA;AACA;iBACwBE,e;AAAT,SAASA,eAAT,OAKZ;AAAA,QAJCC,MAID,QAJCA,MAID;AAAA,QAHCC,IAGD,QAHCA,IAGD;AAAA,QAFCC,QAED,QAFCA,QAED;AAAA,QADCC,YACD,QADCA,YACD;AAAA,QACSC,UADT,GACwBC,UADxB,CACSD,UADT;AAAA,QAESN,WAFT,GAEyBI,QAFzB,CAESJ,WAFT;AAAA,kBAGsBQ,MAHtB;AAAA,QAGSC,QAHT,WAGSA,QAHT;;;AAKCH,eAAWI,SAAX,GAAuB,CAAvB;;AAEA;AACA;AACA;AACA,QAAMC,SAASX,YAAYY,KAAZ,CAAkBN,UAAlB,CAAf;;AAEA;AACA,QAAMO,WAAWJ,SAASK,sBAAT,EAAjB;;AAbD,uBAecH,MAfd,EAe8BI,KAf9B,MAeuBC,KAfvB,uBAeuBA,KAfvB,WAe8BD,KAf9B,GAe8BA,KAf9B,OAe8BA,KAf9B,IAewC;AACnC,YAAIC,KAAJ,EAAW;AACP,gBAAMC,cAAcR,SAASS,cAAT,CAAwBF,KAAxB,CAApB;AACAH,qBAASM,WAAT,CAAqBF,WAArB;;AAEA;AACA;AACA,gBAAIF,QAAQ,CAAR,KAAc,CAAlB,EAAqB;AACjBK,yBAASlB,MAAT,EAAiBc,KAAjB,EAAwBC,WAAxB,EAAqCpB,cAArC,EAAqDQ,YAArD;AACH;AACJ;AACJ;;AAEDF,SAAKkB,YAAL,CAAkBR,QAAlB,EAA4BT,QAA5B;AACAD,SAAKmB,WAAL,CAAiBlB,QAAjB;AACH","file":"_processtextnode.js","sourcesContent":["import parserData from './_parserdata';\nimport bindNode from '../bindnode';\n\nconst textNodeBinder = {\n    setValue(value) {\n        this.textContent = typeof value === 'undefined' ? '' : value;\n    }\n};\n\n// adds binding for text node\n// it splits up one text node into \"simple text nodes\"\n// and \"bound text nodes\" and removes original text node\nexport default function processTextNode({\n    object,\n    node,\n    textNode,\n    eventOptions\n}) {\n    const { bindingReg } = parserData;\n    const { textContent } = textNode;\n    const { document } = window;\n\n    bindingReg.lastIndex = 0;\n\n    // tokens variable contains normal text as odd items\n    // and bound keys as even items\n    // 'foo{{x}}bar{{y}}baz{{z}}' -> ['foo', 'x', 'bar', 'y', 'baz', 'z', '']\n    const tokens = textContent.split(bindingReg);\n\n    // fragment contains all new text nodes\n    const fragment = document.createDocumentFragment();\n\n    nofn.forEach(tokens, (token, index) => {\n        if (token) {\n            const newTextNode = document.createTextNode(token);\n            fragment.appendChild(newTextNode);\n\n            // if tokens item is even then it is a key\n            // which needs to be bound to newly created text node\n            if (index % 2 !== 0) {\n                bindNode(object, token, newTextNode, textNodeBinder, eventOptions);\n            }\n        }\n    });\n\n    node.insertBefore(fragment, textNode);\n    node.removeChild(textNode);\n}\n"]}