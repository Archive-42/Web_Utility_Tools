'use strict';

var checkObjectType = require('../_helpers/checkobjecttype');

var dom = require('../_dom');

var parserData = require('./_parserdata');

var processTextNode = require('./_processtextnode');

var processAttribute = require('./_processattribute');

var getNodes = require('../bindnode/_getnodes');

// makes parsing of given node (node, $(nodes), selector, HTML)
// and initializes bindings for attributes and text nodes which contain things like {{foo}}
module.exports = parseBindings;
function parseBindings(object, givenNodes, eventOptions) {
    if (typeof this === 'object' && this.isMatreshka) {
        // when context is Matreshka instance, use this as an object and shift other args
        /* eslint-disable no-param-reassign */
        eventOptions = givenNodes;
        givenNodes = object;
        object = this;
        /* eslint-enable no-param-reassign */
    } else {
        // throw error when object type is wrong
        checkObjectType(object, 'parseBindings');
    }

    var extendedEventOptions = {
        // useExactBinder is little optimization
        // without this option used binder is extended by default binder
        useExactBinder: true,
        fromParser: true,
        setValueOnBind: true
    };

    if (typeof eventOptions === 'object') {
        var _result = extendedEventOptions;

        for (var _source2 = eventOptions, _keys2 = Object.keys(_source2), _l2 = _keys2.length, _i2 = 0, _key2; _i2 < _l2; _i2++) {
            _key2 = _keys2[_i2];
            _result[_key2] = _source2[_key2];
        }
    }

    var nodes = void 0;
    var allNodes = [];
    // extract all needed data from parserData
    // check out what is parserData in its module
    var leftBracket = parserData.leftBracket,
        bindingReg = parserData.bindingReg;


    if (typeof givenNodes === 'string') {
        if (~givenNodes.indexOf('<')) {
            // this is HTML
            nodes = dom.$.parseHTML(givenNodes);
            if (!~givenNodes.indexOf(leftBracket)) {
                // if it doesn't include parser bracket then we don't need to check
                // their existence for all included nodes in cycle below
                return nodes;
            }
        } else {
            // this is a selector
            nodes = getNodes(object, givenNodes);
        }
    } else if (typeof givenNodes === 'object') {
        // this is a node, nodeList or something else (eg array, jQuery instance etc)
        nodes = dom.$(givenNodes);
    }

    // to make possible to not use recursion we're collecting all nodes to allNodes array

    // on every cycle of array we're adding new descendants to allNodes
    // increasing # of needed iterations
    for (var _target = nodes, _index = 0, node, _l3 = _target.length; node = _target[_index], _index < _l3; _index++) {
        allNodes.push(node)
    }

    var _loop = function (i) {
        var node = allNodes[i];
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;

        // allow to parse elements only
        if (node.nodeType !== ELEMENT_NODE) {
            return 'continue';
        }

        var outerHTML = node.outerHTML,
            innerHTML = node.innerHTML,
            childNodes = node.childNodes,
            attributes = node.attributes;

        // if outerHTML does't contain left bracket, then this node doesn't need to be parsed
        // we may need to check outerHTML existence for older browsers
        // we may need to add !~outerHTML.indexOf(encodeURI(leftBracket) to support old FF

        if (!~outerHTML.indexOf(leftBracket)) {
            return 'continue';
        }

        // initialize bindings for attributes if they appear
        if (attributes.length) {
            // fixes Firefox issue: attributes.length can be changed by processAttribute
            var attrs = attributes.length > 1 ? [].concat(attributes) : attributes;

            for (var _target2 = attrs, _index2 = 0, attribute, _l4 = _target2.length; attribute = _target2[_index2], _index2 < _l4; _index2++) {
                if (bindingReg.test(attribute.value)) {
                    processAttribute({
                        node: node,
                        attribute: attribute,
                        object: object,
                        eventOptions: extendedEventOptions
                    });
                }
            }
        }

        // if innerHTML does't contain left bracket,
        // then children of this node don't need to be parsed
        // we may need to add !~innerHTML.indexOf(encodeURI(leftBracket) to support old FF
        if (!~innerHTML.indexOf(leftBracket)) {
            return 'continue';
        }

        for (var j = 0; j < childNodes.length; j++) {
            var childNode = childNodes[j];
            var nodeType = childNode.nodeType,
                textContent = childNode.textContent;


            if (nodeType === ELEMENT_NODE) {
                // if childNode is HTML element then add it to the end of allNodes array
                // to check everything on next outer cycle iterations
                allNodes.push(childNode);
            } else if (nodeType === TEXT_NODE) {
                // if childNode is text node which contains things like {{x}}
                // then initialize bindings for this node
                if (bindingReg.test(textContent)) {
                    processTextNode({
                        object: object,
                        node: node,
                        textNode: childNode,
                        eventOptions: extendedEventOptions
                    });
                }
            }
        }
    };

    for (var i = 0; i < allNodes.length; i++) {
        var _ret = _loop(i);

        if (_ret === 'continue') continue;
    }

    return nodes;
}
//# sourceMappingURL=index.js.map