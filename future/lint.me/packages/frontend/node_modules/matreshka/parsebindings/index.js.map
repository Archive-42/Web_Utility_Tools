{"version":3,"sources":["../../src/parsebindings/index.js"],"names":["parseBindings","object","givenNodes","eventOptions","isMatreshka","checkObjectType","extendedEventOptions","useExactBinder","fromParser","setValueOnBind","nodes","allNodes","leftBracket","parserData","bindingReg","indexOf","dom","$","parseHTML","getNodes","node","push","i","ELEMENT_NODE","TEXT_NODE","nodeType","outerHTML","innerHTML","childNodes","attributes","length","attrs","attribute","test","value","processAttribute","j","childNode","textContent","processTextNode","textNode"],"mappings":"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","file":"index.js","sourcesContent":["import checkObjectType from '../_helpers/checkobjecttype';\nimport dom from '../_dom';\nimport parserData from './_parserdata';\nimport processTextNode from './_processtextnode';\nimport processAttribute from './_processattribute';\nimport getNodes from '../bindnode/_getnodes';\n\n// makes parsing of given node (node, $(nodes), selector, HTML)\n// and initializes bindings for attributes and text nodes which contain things like {{foo}}\nexport default function parseBindings(object, givenNodes, eventOptions) {\n    if (typeof this === 'object' && this.isMatreshka) {\n        // when context is Matreshka instance, use this as an object and shift other args\n        /* eslint-disable no-param-reassign */\n        eventOptions = givenNodes;\n        givenNodes = object;\n        object = this;\n        /* eslint-enable no-param-reassign */\n    } else {\n        // throw error when object type is wrong\n        checkObjectType(object, 'parseBindings');\n    }\n\n    const extendedEventOptions = {\n        // useExactBinder is little optimization\n        // without this option used binder is extended by default binder\n        useExactBinder: true,\n        fromParser: true,\n        setValueOnBind: true\n    };\n\n    if (typeof eventOptions === 'object') {\n        nofn.assign(extendedEventOptions, eventOptions);\n    }\n\n    let nodes;\n    const allNodes = [];\n    // extract all needed data from parserData\n    // check out what is parserData in its module\n    const {\n        leftBracket,\n        bindingReg\n    } = parserData;\n\n    if (typeof givenNodes === 'string') {\n        if (~givenNodes.indexOf('<')) {\n            // this is HTML\n            nodes = dom.$.parseHTML(givenNodes);\n            if (!~givenNodes.indexOf(leftBracket)) {\n                // if it doesn't include parser bracket then we don't need to check\n                // their existence for all included nodes in cycle below\n                return nodes;\n            }\n        } else {\n            // this is a selector\n            nodes = getNodes(object, givenNodes);\n        }\n    } else if (typeof givenNodes === 'object') {\n        // this is a node, nodeList or something else (eg array, jQuery instance etc)\n        nodes = dom.$(givenNodes);\n    }\n\n    // to make possible to not use recursion we're collecting all nodes to allNodes array\n    nofn.forEach(nodes, node => allNodes.push(node));\n\n    // on every cycle of array we're adding new descendants to allNodes\n    // increasing # of needed iterations\n    for (let i = 0; i < allNodes.length; i++) {\n        const node = allNodes[i];\n        const ELEMENT_NODE = 1;\n        const TEXT_NODE = 3;\n\n        // allow to parse elements only\n        if (node.nodeType !== ELEMENT_NODE) {\n            continue;\n        }\n\n        const { outerHTML, innerHTML, childNodes, attributes } = node;\n\n\n        // if outerHTML does't contain left bracket, then this node doesn't need to be parsed\n        // we may need to check outerHTML existence for older browsers\n        // we may need to add !~outerHTML.indexOf(encodeURI(leftBracket) to support old FF\n        if (!~outerHTML.indexOf(leftBracket)) {\n            continue;\n        }\n\n        // initialize bindings for attributes if they appear\n        if (attributes.length) {\n            // fixes Firefox issue: attributes.length can be changed by processAttribute\n            const attrs = attributes.length > 1 ? [...attributes] : attributes;\n            nofn.forEach(attrs, (attribute) => {\n                if (bindingReg.test(attribute.value)) {\n                    processAttribute({\n                        node,\n                        attribute,\n                        object,\n                        eventOptions: extendedEventOptions\n                    });\n                }\n            });\n        }\n\n        // if innerHTML does't contain left bracket,\n        // then children of this node don't need to be parsed\n        // we may need to add !~innerHTML.indexOf(encodeURI(leftBracket) to support old FF\n        if (!~innerHTML.indexOf(leftBracket)) {\n            continue;\n        }\n\n        for (let j = 0; j < childNodes.length; j++) {\n            const childNode = childNodes[j];\n            const { nodeType, textContent } = childNode;\n\n            if (nodeType === ELEMENT_NODE) {\n                // if childNode is HTML element then add it to the end of allNodes array\n                // to check everything on next outer cycle iterations\n                allNodes.push(childNode);\n            } else if (nodeType === TEXT_NODE) {\n                // if childNode is text node which contains things like {{x}}\n                // then initialize bindings for this node\n                if (bindingReg.test(textContent)) {\n                    processTextNode({\n                        object,\n                        node,\n                        textNode: childNode,\n                        eventOptions: extendedEventOptions\n                    });\n                }\n            }\n        }\n    }\n\n    return nodes;\n}\n"]}