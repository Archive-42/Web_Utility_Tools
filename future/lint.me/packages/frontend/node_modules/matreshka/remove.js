'use strict';

var unbindNode = require('./unbindnode');

var triggerOne = require('./trigger/_triggerone');

var removeListener = require('./off/_removelistener');

var defs = require('./_core/defs');

var checkObjectType = require('./_helpers/checkobjecttype');

var matreshkaError = require('./_helpers/matreshkaerror');

// removes a property, its bindings and its events
// TODO: remove function does not correctly removes delegated events, bindings, tree listeners etc
module.exports = remove;
function remove(object, givenKey, eventOptions) {
    if (typeof this === 'object' && this.isMatreshka) {
        // when context is Matreshka instance, use this as an object and shift other args
        /* eslint-disable no-param-reassign */
        eventOptions = givenKey;
        givenKey = object;
        object = this;
        /* eslint-enable no-param-reassign */
    } else {
        // throw error when object type is wrong
        checkObjectType(object, 'remove');
    }

    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign
    var def = defs.get(object);
    var _eventOptions = eventOptions,
        silent = _eventOptions.silent;
    // allow to pass single key or an array of keys

    var keys = givenKey instanceof Array ? givenKey : [givenKey];

    var _loop = function (i) {
        var key = keys[i];

        // if non-string is passed as a key
        if (typeof key !== 'string') {
            throw matreshkaError('remove:key_type', { key: key });
        }

        var props = def && def.props;
        var propDef = props && props[key];

        // if no object definition then simply delete the property
        if (!propDef) {
            delete object[key];
            return 'continue';
        }

        var value = propDef.value;

        // remove all bindings

        unbindNode(object, key);

        // TODO: Manual listing of event prefixes may cause problems in future
        var removeEventPrefies = ['_change:deps', '_change:bindings', '_change:delegated', '_change:tree', 'change', 'beforechange', 'bind', 'unbind'];

        // remove all events

        // delete property definition
        for (var _target = removeEventPrefies, _index = 0, prefix, _l = _target.length; prefix = _target[_index], _index < _l; _index++) {
            removeListener(object, prefix + ':' + key)
        }

        delete props[key];

        // delete the property itself
        delete object[key];

        var _keys,
            _l2,
            _i,
            _source,
            _key,
            _result = {};

        _result.key = key
        _result.value = value

        for (_source = eventOptions, _keys = Object.keys(_source), _l2 = _keys.length, _i = 0; _i < _l2; _i++) {
            _key = _keys[_i];
            _result[_key] = _source[_key];
        }

        var extendedEventOptions = _result;

        // trigger delegated events logic removal for asterisk events (*.*.*@foo)
        triggerOne(object, '_delete:delegated', extendedEventOptions);

        // fire events if "silent" is not true
        if (!silent) {
            triggerOne(object, 'delete', extendedEventOptions);
            triggerOne(object, 'delete:' + key, extendedEventOptions);
        }
    };

    for (var i = 0; i < keys.length; i++) {
        var _ret = _loop(i);

        if (_ret === 'continue') continue;
    }
}
//# sourceMappingURL=remove.js.map