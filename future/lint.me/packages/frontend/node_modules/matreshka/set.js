'use strict';

var defs = require('./_core/defs');

var triggerOne = require('./trigger/_triggerone');

var checkObjectType = require('./_helpers/checkobjecttype');

var is = require('./_helpers/is');

// the function sets new value for a property
// since its performance is very critical we're checking events existence manually
module.exports = set;
function set(object, key, value, eventOptions) {
    if (typeof this === 'object' && this.isMatreshka) {
        // when context is Matreshka instance, use this as an object and shift other args
        /* eslint-disable no-param-reassign */
        eventOptions = value;
        value = key;
        key = object;
        object = this;
        /* eslint-enable no-param-reassign */
    } else {
        // throw error when object type is wrong
        checkObjectType(object, 'set');
    }

    // if no key or falsy key is given
    if (!key) {
        return object;
    }

    // allow to use key-value object as another method variation
    if (typeof key === 'object') {
        for (var _target = key, _keys = Object.keys(_target), _i = 0, objKey, objVal, _l = _keys.length; (objKey = _keys[_i], objVal = _target[objKey]), _i < _l; _i++) {
            set(object, objKey, objVal, value)
        }

        return object;
    }

    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign
    var def = defs.get(object);

    // if no object definition then make simple assignment
    if (!def) {
        object[key] = value;
        return object;
    }

    var props = def.props,
        events = def.events;

    var propDef = props[key];

    // if no property definition then make simple assignment
    if (!propDef) {
        object[key] = value;
        return object;
    }

    var previousValue = propDef.value,
        mediator = propDef.mediator;

    // possible flags, all of them are falsy by default

    var _eventOptions = eventOptions,
        skipMediator = _eventOptions.skipMediator,
        fromMediator = _eventOptions.fromMediator,
        force = _eventOptions.force,
        forceHTML = _eventOptions.forceHTML,
        silent = _eventOptions.silent,
        silentHTML = _eventOptions.silentHTML,
        skipCalc = _eventOptions.skipCalc;


    var newValue = void 0;

    if (mediator && !is(value, previousValue) && !skipMediator && !fromMediator) {
        newValue = mediator(value);
    } else {
        newValue = value;
    }

    var isChanged = !is(newValue, previousValue);

    // add to eventOptions object some useful properties
    // we override default eventOptions because some of the properties need to have actual values,
    // not inherited ones (eg when calc is used)

    var _keys2,
        _l2,
        _i2,
        _source,
        _key,
        _result = {};

    for (_source = eventOptions, _keys2 = Object.keys(_source), _l2 = _keys2.length, _i2 = 0; _i2 < _l2; _i2++) {
        _key = _keys2[_i2];
        _result[_key] = _source[_key];
    }

    _result.value = newValue
    _result.self = object
    _result.previousValue = previousValue
    _result.key = key
    _result.isChanged = isChanged
    var extendedEventOptions = _result;

    var triggerChange = (isChanged || force) && !silent;

    // trigger beforechange:KEY and beforechange events
    if (triggerChange) {
        var beforechangeStr = 'beforechange';
        var beforechangeEventName = beforechangeStr + ':' + key;

        if (events[beforechangeEventName]) {
            triggerOne(object, beforechangeEventName, extendedEventOptions);
        }

        if (events[beforechangeStr]) {
            triggerOne(object, beforechangeStr, extendedEventOptions);
        }
    }

    propDef.value = newValue;

    // triger bindings
    if (!silentHTML && (isChanged || forceHTML)) {
        var changeBindingsEventName = '_change:bindings:' + key;
        if (events[changeBindingsEventName]) {
            triggerOne(object, changeBindingsEventName, extendedEventOptions);
        }
    }

    // trigger change:KEY and change events
    if (triggerChange) {
        var changeStr = 'change';
        var changeEventName = changeStr + ':' + key;
        if (events[changeEventName]) {
            triggerOne(object, changeEventName, extendedEventOptions);
        }

        if (events[changeStr]) {
            triggerOne(object, changeStr, extendedEventOptions);
        }
    }

    // trigger dependencies made by calc method
    if ((isChanged || force) && !skipCalc) {
        var changeDepsEventName = '_change:deps:' + key;
        if (events[changeDepsEventName]) {
            triggerOne(object, changeDepsEventName, extendedEventOptions);
        }
    }

    if (isChanged) {
        // trigger common delegated events logic
        var changeDelegatedKeyEventName = '_change:delegated:' + key;
        if (events[changeDelegatedKeyEventName]) {
            triggerOne(object, changeDelegatedKeyEventName, extendedEventOptions);
        }

        // trigger tree change events logic
        var changeTreeEventName = '_change:tree:' + key;
        if (events[changeTreeEventName]) {
            triggerOne(object, changeTreeEventName, extendedEventOptions);
        }

        // trigger other internal change events
        var changeCommonEventName = '_change:common:' + key;
        if (events[changeCommonEventName]) {
            triggerOne(object, changeCommonEventName, extendedEventOptions);
        }

        // trigger delegated logic for asterisk events (*.*.*@foo)
        // TODO: Confusing events names ("_change:delegated", "_change:common:KEY" etc)
        var changeDelegatedEventName = '_change:delegated';
        if (events[changeDelegatedEventName]) {
            triggerOne(object, changeDelegatedEventName, extendedEventOptions);
        }
    }

    return object;
}
//# sourceMappingURL=set.js.map