'use strict';

var checkObjectType = require('../_helpers/checkobjecttype');

var defs = require('../_core/defs');

var getNodes = require('../bindnode/_getnodes');

var removeTreeListener = require('../off/_removetreelistener');

var removeBinding = require('./_removebinding');

var dom = require('../_dom');

// unbinds a node
module.exports = unbindNode;
function unbindNode(object, key, node, eventOptions) {
    if (typeof this === 'object' && this.isMatreshka) {
        // when context is Matreshka instance, use this as an object and shift other args
        /* eslint-disable no-param-reassign */
        eventOptions = node;
        node = key;
        key = object;
        object = this;
        /* eslint-enable no-param-reassign */
    } else {
        // throw error when object type is wrong
        checkObjectType(object, 'unbindNode');
    }

    if (key instanceof Array) {
        if (typeof key[0] === 'string') {
            for (var _target = key, _index = 0, itemKey, _l = _target.length; itemKey = _target[_index], _index < _l; _index++) {
                unbindNode(object, itemKey, node, eventOptions)
            }
            /*
             * accept array of keys
             * this.unbindNode(['a', 'b', 'c'], node)
             */
        } else {
            for (var _target2 = key, _index2 = 0, _ref, _l6 = _target2.length; _ref = _target2[_index2], _index2 < _l6; _index2++) {
                var itemKey = _ref.key,
                    itemNode = _ref.node,
                    itemEventOptions = _ref.event;

                var commonEventOptions = node;
                var mergedEventOptions = {};

                if (commonEventOptions) {
                    var _result = mergedEventOptions;
                    // extend event object by "global" event

                    for (var _source2 = commonEventOptions, _keys2 = Object.keys(_source2), _l3 = _keys2.length, _i2 = 0, _key2; _i2 < _l3; _i2++) {
                        _key2 = _keys2[_i2];
                        _result[_key2] = _source2[_key2];
                    }
                }

                if (itemEventOptions) {
                    var _result2 = mergedEventOptions;
                    // extend event object by "local" event ("event" key of an object)

                    for (var _source4 = itemEventOptions, _keys4 = Object.keys(_source4), _l5 = _keys4.length, _i4 = 0, _key4; _i4 < _l5; _i4++) {
                        _key4 = _keys4[_i4];
                        _result2[_key4] = _source4[_key4];
                    }
                }

                unbindNode(object, itemKey, itemNode, mergedEventOptions);
            }
            /*
             * acept array of objects
             * this.unbindNode([{ key, node, binder, event }], { silent: true });
             */

        }

        return object;
    }

    if (key && typeof key === 'object') {
        for (var _target4 = key, _keys5 = Object.keys(_target4), _i5 = 0, keyObjKey, keyObjValue, _l8 = _keys5.length; (keyObjKey = _keys5[_i5], keyObjValue = _target4[keyObjKey]), _i5 < _l8; _i5++) {
            if (keyObjValue.constructor === Object && 'node' in keyObjValue) {
                // this.unbindNode({ key: { node: $(), binder } ) }, { silent: true });
                unbindNode(object, keyObjKey, keyObjValue.node, node);
            } else if (keyObjValue.constructor === Array && keyObjValue.length && keyObjValue[0].constructor === Object && 'node' in keyObjValue[0]) {
                for (var _target3 = keyObjValue, _index3 = 0, keyObjValueItem, _l7 = _target3.length; keyObjValueItem = _target3[_index3], _index3 < _l7; _index3++) {
                    unbindNode(object, keyObjKey, keyObjValueItem.node, node);
                }
                // this.unbindNode({ key: [{ node: $(), binder }] ) }, { silent: true });

            } else {
                // this.unbindNode({ key: $() }, { silent: true });
                unbindNode(object, keyObjKey, keyObjValue, node);
            }
        }

        return object;
    }

    eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign
    var _eventOptions = eventOptions,
        deep = _eventOptions.deep;

    var def = defs.get(object);

    if (!def) {
        return object;
    }

    var props = def.props;

    // allow to pass null or undefined as key
    // if passed then remove bindings of all keys for given object

    if (key === null || typeof key === 'undefined') {
        for (var _target5 = props, _keys6 = Object.keys(_target5), _i6 = 0, propsKey, propsItem, _l9 = _keys6.length; (propsKey = _keys6[_i6], propsItem = _target5[propsKey]), _i6 < _l9; _i6++) {
            unbindNode(object, propsKey, null, eventOptions);
        }

        return object;
    }

    // remove delegated binding
    if (deep !== false) {
        var deepPath = key.split('.');
        var deepPathLength = deepPath.length;

        if (deepPathLength > 1) {
            var target = object;

            for (var i = 0; i < deepPathLength - 1; i++) {
                // TODO: Do we need to throw an error when a target is falsy?
                target = target[deepPath[i]];
            }

            // TODO: Potential bug! This may undelegate listener for all bindings with the same path
            // ...(cannot reproduce)
            removeTreeListener(object, deepPath.slice(0, deepPathLength - 2));

            unbindNode(target, deepPath[deepPathLength - 1], node, eventOptions);

            return object;
        }
    }

    var propDef = props[key];

    // when no propdef do nothing
    if (!propDef) {
        return object;
    }

    var bindings = propDef.bindings;

    // if the property doesn't have any bindings do nothing

    if (!bindings) {
        return object;
    }

    // if no node is pased remove all bindings for given key
    if (!node) {
        for (var _target6 = bindings, _index4 = 0, binding, _l10 = _target6.length; binding = _target6[_index4], _index4 < _l10; _index4++) {
            removeBinding({ object: object, key: key, eventOptions: eventOptions, binding: binding });
        }

        propDef.bindings = null;

        // update nodes and $nodes for Matreshka instance
        if (object.isMatreshka) {
            delete object.nodes[key];
            delete object.$nodes[key];
        }

        return object;
    }

    var $nodes = getNodes(object, node);
    var retainBindings = [];
    var retainNodes = [];

    // iterate over all bindngs and compare their node with given nodes

    // update nodes and $nodes for Matreshka instance
    for (var _target8 = $nodes, _index6 = 0, nodesItem, _l12 = _target8.length; nodesItem = _target8[_index6], _index6 < _l12; _index6++) {
        for (var _target7 = bindings, _index5 = 0, binding, _l11 = _target7.length; binding = _target7[_index5], _index5 < _l11; _index5++) {
            if (binding.node === nodesItem) {
                removeBinding({ object: object, key: key, eventOptions: eventOptions, binding: binding });
            } else {
                retainBindings.push(binding);
                retainNodes.push(nodesItem);
            }
        }
    }

    if (object.isMatreshka) {
        if (retainNodes.length) {
            object.nodes[key] = retainNodes[0];
            object.$nodes[key] = dom.$(retainNodes);
        } else {
            delete object.nodes[key];
            delete object.$nodes[key];
        }
    }

    // update bindings object
    if (retainBindings.length) {
        propDef.bindings = retainBindings;
    } else {
        propDef.bindings = null;
    }

    return object;
}
//# sourceMappingURL=index.js.map