{"version":3,"sources":["../../../src/array/recreate/_updatetracked.js"],"names":["updateTracked","givenNewItems","arr","trackBy","newLength","length","oldLength","newItems","Array","i","item","newItem","trackMap"],"mappings":";;;;;;;;;;;AAAA;;AAEA;AACA;AACe,SAASA,aAAT,OAIZ;AAAA,MAHDC,aAGC,QAHDA,aAGC;AAAA,MAFDC,GAEC,QAFDA,GAEC;AAAA,MADDC,OACC,QADDA,OACC;AACD,MAAMC,SAAS,GAAGH,aAAa,CAACI,MAAhC;AACA,MAAMC,SAAS,GAAGJ,GAAG,CAACG,MAAtB;AACA,MAAME,QAAQ,GAAGC,KAAK,CAACJ,SAAD,CAAtB;;AAEA,MAAID,OAAO,KAAK,QAAhB,EAA0B;AACxB;AACA,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,SAApB,EAA+BK,CAAC,EAAhC,EAAoC;AAClC,UAAMC,IAAI,GAAGR,GAAG,CAACO,CAAD,CAAhB;AACA,UAAME,OAAO,GAAGV,aAAa,CAACQ,CAAD,CAA7B;;AAEA,UACEC,IAAI,IAAI,yBAAOA,IAAP,MAAgB,QAAxB,IACWC,OADX,IACsB,yBAAOA,OAAP,MAAmB,QAF3C,EAGE;AACAJ,QAAAA,QAAQ,CAACE,CAAD,CAAR,GAAc,8BAAaC,IAAb,EAAmBC,OAAnB,CAAd;AACD,OALD,MAKO;AACLJ,QAAAA,QAAQ,CAACE,CAAD,CAAR,GAAcE,OAAd;AACD;AACF;AACF,GAfD,MAeO;AACL,QAAMC,QAAQ,GAAG,EAAjB,CADK,CAGL;;AACA,SAAK,IAAIH,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGH,SAApB,EAA+BG,EAAC,EAAhC,EAAoC;AAClC,UAAMC,KAAI,GAAGR,GAAG,CAACO,EAAD,CAAhB;;AAEA,UAAIC,KAAI,IAAI,yBAAOA,KAAP,MAAgB,QAA5B,EAAsC;AACpC,YAAIP,OAAO,IAAIO,KAAf,EAAqB;AACnBE,UAAAA,QAAQ,CAACF,KAAI,CAACP,OAAD,CAAL,CAAR,GAA0BO,KAA1B;AACD;AACF;AACF;;AAED,SAAK,IAAID,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGL,SAApB,EAA+BK,GAAC,EAAhC,EAAoC;AAClC,UAAME,QAAO,GAAGV,aAAa,CAACQ,GAAD,CAA7B;;AAEA,UAAIE,QAAO,IAAI,yBAAOA,QAAP,MAAmB,QAAlC,EAA4C;AAC1C,YAAMD,MAAI,GAAGR,GAAG,CAACO,GAAD,CAAhB;;AAEA,YAAIC,MAAI,IAAI,yBAAOA,MAAP,MAAgB,QAAxB,IAAoCC,QAAO,CAACR,OAAD,CAAP,IAAoBS,QAA5D,EAAsE;AACpE;AACAL,UAAAA,QAAQ,CAACE,GAAD,CAAR,GAAc,8BAAaG,QAAQ,CAACD,QAAO,CAACR,OAAD,CAAR,CAArB,EAAyCQ,QAAzC,CAAd;AACD,SAHD,MAGO;AACL;AACAJ,UAAAA,QAAQ,CAACE,GAAD,CAAR,GAAcE,QAAd;AACD;AACF,OAVD,MAUO;AACL;AACAJ,QAAAA,QAAQ,CAACE,GAAD,CAAR,GAAcE,QAAd;AACD;AACF;AACF;;AAED,SAAOJ,QAAP;AACD","sourcesContent":["import updateObject from './_updateobject';\n\n// the function gets called to update new items passed to recreate method when trackBy is present\n// TODO: Throw an error when two or more items of one array has the same value of trackBy\nexport default function updateTracked({\n  givenNewItems,\n  arr,\n  trackBy\n}) {\n  const newLength = givenNewItems.length;\n  const oldLength = arr.length;\n  const newItems = Array(newLength);\n\n  if (trackBy === '$index') {\n    // simply update items with the same index\n    for (let i = 0; i < newLength; i++) {\n      const item = arr[i];\n      const newItem = givenNewItems[i];\n\n      if (\n        item && typeof item === 'object'\n                && newItem && typeof newItem === 'object'\n      ) {\n        newItems[i] = updateObject(item, newItem);\n      } else {\n        newItems[i] = newItem;\n      }\n    }\n  } else {\n    const trackMap = {};\n\n    // fill trackMap object where keys are values of trackBy and values are corresponding items\n    for (let i = 0; i < oldLength; i++) {\n      const item = arr[i];\n\n      if (item && typeof item === 'object') {\n        if (trackBy in item) {\n          trackMap[item[trackBy]] = item;\n        }\n      }\n    }\n\n    for (let i = 0; i < newLength; i++) {\n      const newItem = givenNewItems[i];\n\n      if (newItem && typeof newItem === 'object') {\n        const item = arr[i];\n\n        if (item && typeof item === 'object' && newItem[trackBy] in trackMap) {\n          // if an item exists at trackMap then update it\n          newItems[i] = updateObject(trackMap[newItem[trackBy]], newItem);\n        } else {\n          // if not then use new value as is\n          newItems[i] = newItem;\n        }\n      } else {\n        // newItem is not an object\n        newItems[i] = newItem;\n      }\n    }\n  }\n\n  return newItems;\n}\n"],"file":"_updatetracked.js"}