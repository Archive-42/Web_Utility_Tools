"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = restore;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _init = _interopRequireDefault(require("../_core/init"));

var _seempleerror = _interopRequireDefault(require("../_helpers/seempleerror"));

var _foreach = _interopRequireDefault(require("../_helpers/foreach"));

var _bindnode = _interopRequireDefault(require("../bindnode"));

var _triggerone = _interopRequireDefault(require("../trigger/_triggerone"));

var _getnodes = _interopRequireDefault(require("../bindnode/_getnodes"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// restores Seemple.Array from external nodes
function restore(selector) {
  var _this = this;

  var eventOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var selfDef = (0, _init["default"])(this);
  var Model = this.Model;
  var silent = eventOptions.silent;
  var newItems = [];
  var nodes;

  if (typeof selector === 'string') {
    // get nodes by selector
    nodes = (0, _getnodes["default"])(this, selector);
  } else {
    // get nodes from rendering container
    var container = this.nodes.container || this.nodes.sandbox;

    if (container) {
      nodes = container.children;
    } else {
      // no container is bound, throw an error
      throw (0, _seempleerror["default"])('restore:no_nodes');
    }
  }

  (0, _foreach["default"])(nodes, function (node, index) {
    var item = Model ? new Model({}, _this, index) : {}; // create new item

    var bindRenderedAsSandbox = item.bindRenderedAsSandbox;
    var itemDef = (0, _init["default"])(item);
    itemDef.renderedInArrays = (0, _defineProperty2["default"])({}, selfDef.id, node);

    if (bindRenderedAsSandbox !== false) {
      (0, _bindnode["default"])(item, 'sandbox', node, null, eventOptions);
    }

    if (!silent) {
      // trigger needed events
      var itemEventOptions = {
        node: node,
        self: item,
        parentArray: _this
      };
      var onRender = item.onRender;
      var onItemRender = _this.onItemRender;

      if (onRender) {
        onRender.call(item, itemEventOptions);
      }

      if (onItemRender) {
        onItemRender.call(_this, item, itemEventOptions);
      }

      (0, _triggerone["default"])(item, 'render', itemEventOptions); // call afterrender immediately because a node already exists in DOM tree

      (0, _triggerone["default"])(item, 'afterrender', itemEventOptions);
    }

    newItems.push(item);
  }); // recreate an array but don't render newly added items

  return this.recreate(newItems, _objectSpread({
    dontRender: true
  }, eventOptions));
}
//# sourceMappingURL=restore.js.map