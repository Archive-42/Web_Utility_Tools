"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = off;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _splitbyspaceregexp = _interopRequireDefault(require("../on/_splitbyspaceregexp"));

var _checkobjecttype = _interopRequireDefault(require("../_helpers/checkobjecttype"));

var _forown = _interopRequireDefault(require("../_helpers/forown"));

var _foreach = _interopRequireDefault(require("../_helpers/foreach"));

var _defs = _interopRequireDefault(require("../_core/defs"));

var _removelistener = _interopRequireDefault(require("./_removelistener"));

var _undelegatelistener = _interopRequireDefault(require("./_undelegatelistener"));

var _dom = _interopRequireDefault(require("../_dom"));

// removes event listener
function off(object, givenNames, callback, context) {
  if ((0, _typeof2["default"])(this) === 'object' && this.isSeemple) {
    // when context is Seemple instance, use this as an object and shift other args

    /* eslint-disable no-param-reassign */
    context = callback;
    callback = givenNames;
    givenNames = object;
    object = this;
    /* eslint-enable no-param-reassign */
  } else {
    // throw error when object type is wrong
    (0, _checkobjecttype["default"])(object, 'off');
  }

  var isNamesVarArray = givenNames instanceof Array;

  var def = _defs["default"].get(object); // allow to pass name-handler object
  // TODO: Name-handler object passed to off method is non-documented feature


  if (givenNames && (0, _typeof2["default"])(givenNames) === 'object' && !isNamesVarArray) {
    (0, _forown["default"])(givenNames, function (namesObjCallback, namesObjName) {
      return off(object, namesObjName, namesObjCallback, callback);
    });
    return object;
  }

  if (!givenNames && !callback && !context) {
    def.events = {};
    (0, _forown["default"])(def.props, function (_ref, propName) {
      var bindings = _ref.bindings;

      if (bindings) {
        (0, _foreach["default"])(bindings, function (_ref2) {
          var node = _ref2.node;
          var eventNamespace = def.id + propName;

          _dom["default"].$(node).off(".".concat(eventNamespace));
        });
      }
    });
    return object;
  } // TODO: Array of names passed to off method is non-documented feature
  // split by spaces


  var names = isNamesVarArray ? givenNames : givenNames.split(_splitbyspaceregexp["default"]);
  (0, _foreach["default"])(names, function (name) {
    var delegatedEventParts = name.split('@');

    if (delegatedEventParts.length > 1) {
      var _delegatedEventParts = (0, _slicedToArray2["default"])(delegatedEventParts, 2),
          path = _delegatedEventParts[0],
          delegatedName = _delegatedEventParts[1];

      (0, _undelegatelistener["default"])(object, path, delegatedName, callback, context);
    } else {
      (0, _removelistener["default"])(object, name, callback, context);
    }
  });
  return object;
}
//# sourceMappingURL=index.js.map