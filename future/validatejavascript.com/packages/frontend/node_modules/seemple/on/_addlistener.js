"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = addListener;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _init = _interopRequireDefault(require("../_core/init"));

var _triggerone = _interopRequireDefault(require("../trigger/_triggerone"));

var _defineprop = _interopRequireDefault(require("../_core/defineprop"));

var _domeventregexp = _interopRequireDefault(require("./_domeventregexp"));

// property modifier event regexp
var propModEventReg = /^_change:deps:|^_change:bindings:|^_change:delegated:|^_change:common:|^_change:tree:|^change:|^beforechange:/; // adds simple event listener
// used as core of event engine

function addListener(object, name, callback, context) {
  var info = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var _initSeemple = (0, _init["default"])(object),
      allEvents = _initSeemple.events;

  var ctx = context || object;
  var events = allEvents[name];
  var event = {
    callback: callback,
    context: context,
    ctx: ctx,
    name: name,
    info: info
  }; // skipChecks is used by internal methods for better performance

  var _info$skipChecks = info.skipChecks,
      skipChecks = _info$skipChecks === void 0 ? false : _info$skipChecks;

  if (!skipChecks) {
    var domEventExecResult = _domeventregexp["default"].exec(name);

    if (domEventExecResult) {
      var _domEventExecResult = (0, _slicedToArray2["default"])(domEventExecResult, 4),
          eventName = _domEventExecResult[1],
          _domEventExecResult$ = _domEventExecResult[2],
          key = _domEventExecResult$ === void 0 ? 'sandbox' : _domEventExecResult$,
          selector = _domEventExecResult[3]; // fixing circular reference issue


      var addDomListener = require('./_adddomlistener')["default"];

      addDomListener(object, key, eventName, selector, callback, context, info);
      return true;
    }
  } // if there are events with the same name


  if (events) {
    if (!skipChecks) {
      // if there are events with the same data, return false
      for (var i = 0; i < events.length; i++) {
        var existingEvent = events[i];
        var argCallback = callback && callback._callback || callback;
        var eventCallback = existingEvent.callback._callback || existingEvent.callback;

        if (argCallback === eventCallback && existingEvent.context === context) {
          return false;
        }
      }
    } // if the event isn't found add it to the event list


    events.push(event);
  } else {
    // if there are no events with the same name, create an array with only  one event
    allEvents[name] = [event];
  }

  if (propModEventReg.test(name)) {
    // define needed accessors for KEY
    (0, _defineprop["default"])(object, name.replace(propModEventReg, ''));
  } // names prefixed by underscore mean "private" events


  if (!skipChecks && name[0] !== '_') {
    (0, _triggerone["default"])(object, "addevent:".concat(name), event);
    (0, _triggerone["default"])(object, 'addevent', event);
  } // if event is added successfully return true


  return true;
}
//# sourceMappingURL=_addlistener.js.map