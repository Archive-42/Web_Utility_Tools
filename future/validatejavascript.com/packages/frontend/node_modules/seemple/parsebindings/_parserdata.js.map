{"version":3,"sources":["../../src/parsebindings/_parserdata.js"],"names":["parserData","leftBracket","source","object","parserBrackets","key","rightBracket","escLeftBracket","handler","left","replace","escRightBracket","right","bindingReg","RegExp","strictBindingReg","debounceCalc"],"mappings":";;;;;;;;;AAAA;;AACA;;AAEA,IAAMA,UAAU,GAAG,EAAnB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,sBAAKA,UAAL,EAAiB;AACfC,EAAAA,WAAW,EAAE;AACXC,IAAAA,MAAM,EAAE;AACNC,MAAAA,MAAM,EAAEC,0BADF;AAENC,MAAAA,GAAG,EAAE;AAFC;AADG,GADE;AAOfC,EAAAA,YAAY,EAAE;AACZJ,IAAAA,MAAM,EAAE;AACNC,MAAAA,MAAM,EAAEC,0BADF;AAENC,MAAAA,GAAG,EAAE;AAFC;AADI,GAPC;AAafE,EAAAA,cAAc,EAAE;AACdL,IAAAA,MAAM,EAAE,aADM;AAEdM,IAAAA,OAAO,EAAE,iBAACC,IAAD;AAAA,aAAUA,IAAI,CAACC,OAAL,CAAa,aAAb,EAA4B,MAA5B,CAAV;AAAA;AAFK,GAbD;AAiBfC,EAAAA,eAAe,EAAE;AACfT,IAAAA,MAAM,EAAE,cADO;AAEfM,IAAAA,OAAO,EAAE,iBAACI,KAAD;AAAA,aAAWA,KAAK,CAACF,OAAN,CAAc,YAAd,EAA4B,MAA5B,CAAX;AAAA;AAFM,GAjBF;AAqBfG,EAAAA,UAAU,EAAE;AACVX,IAAAA,MAAM,EAAE,CAAC,gBAAD,EAAmB,iBAAnB,CADE;AAEVM,IAAAA,OAAO,EAAE,iBAACC,IAAD,EAAOG,KAAP;AAAA,aAAiB,IAAIE,MAAJ,WAAcL,IAAd,0BAAkCG,KAAlC,GAA2C,GAA3C,CAAjB;AAAA;AAFC,GArBG;AAyBfG,EAAAA,gBAAgB,EAAE;AAChBb,IAAAA,MAAM,EAAE,CAAC,gBAAD,EAAmB,iBAAnB,CADQ;AAEhBM,IAAAA,OAAO,EAAE,iBAACC,IAAD,EAAOG,KAAP;AAAA,aAAiB,IAAIE,MAAJ,YAAeL,IAAf,0BAAmCG,KAAnC,QAA6C,GAA7C,CAAjB;AAAA;AAFO;AAzBH,CAAjB,EA6BG;AACDI,EAAAA,YAAY,EAAE,KADb,CACmB;;AADnB,CA7BH;eAiCehB,U","sourcesContent":["import calc from '../calc';\nimport parserBrackets from '../parserbrackets';\n\nconst parserData = {};\n\n// since Seemple allows to change parser brackets via parserBrackets objects\n// the parser needs to generate required regular expressions and escaped brackets every time\n// when parseBindings is called\n// to optimize this behavior parserData object is created\n// it calculates needed data every time when parserBrackets are changed\n// and when parseBindings function is called it uses previously generated regeps\n// from parserData object\ncalc(parserData, {\n  leftBracket: {\n    source: {\n      object: parserBrackets,\n      key: 'left'\n    }\n  },\n  rightBracket: {\n    source: {\n      object: parserBrackets,\n      key: 'right'\n    }\n  },\n  escLeftBracket: {\n    source: 'leftBracket',\n    handler: (left) => left.replace(/(\\[|\\(|\\?)/g, '\\\\$1')\n  },\n  escRightBracket: {\n    source: 'rightBracket',\n    handler: (right) => right.replace(/(]|\\)|\\?)/g, '\\\\$1')\n  },\n  bindingReg: {\n    source: ['escLeftBracket', 'escRightBracket'],\n    handler: (left, right) => new RegExp(`${left}\\\\s*(.+?)\\\\s*${right}`, 'g')\n  },\n  strictBindingReg: {\n    source: ['escLeftBracket', 'escRightBracket'],\n    handler: (left, right) => new RegExp(`^${left}\\\\s*(.+?)\\\\s*${right}$`, 'g')\n  }\n}, {\n  debounceCalc: false // we need to get new regexps immediately when brackets are changed\n});\n\nexport default parserData;\n"],"file":"_parserdata.js"}