"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getBindingKey;

var _parserdata = _interopRequireDefault(require("../_parserdata"));

var _definehiddencontentproperty = _interopRequireDefault(require("./_definehiddencontentproperty"));

// analyzes string and returns only one key which will be actually bound to an attribute
function getBindingKey(_ref) {
  var object = _ref.object,
      text = _ref.text;
  var strictBindingReg = _parserdata["default"].strictBindingReg,
      bindingReg = _parserdata["default"].bindingReg;
  var keys = [];
  var execResult;
  var key;
  strictBindingReg.lastIndex = 0;
  bindingReg.lastIndex = 0; // extract keys given in parser brackers
  // '{{x}} {{y}}' -> ['x', 'y']

  while (execResult = bindingReg.exec(text)) {
    keys.push(execResult[1]);
  }

  if (keys.length === 1 && strictBindingReg.test(text)) {
    // if there is only one key and if only binding substring is present in a text
    // in other words '{{x}}' is given instead of '{{x}} {{y}}' or '{{x}}foo'
    // then don't create computable property and use that key (eg 'x') for binding
    key = keys[0];
  } else {
    // create hidden computable property
    key = (0, _definehiddencontentproperty["default"])({
      object: object,
      keys: keys,
      text: text
    });
  }

  return key;
}
//# sourceMappingURL=_getbindingkey.js.map