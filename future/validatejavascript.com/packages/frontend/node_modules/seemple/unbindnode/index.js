"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = unbindNode;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _checkobjecttype = _interopRequireDefault(require("../_helpers/checkobjecttype"));

var _defs = _interopRequireDefault(require("../_core/defs"));

var _getnodes = _interopRequireDefault(require("../bindnode/_getnodes"));

var _removetreelistener = _interopRequireDefault(require("../off/_removetreelistener"));

var _foreach = _interopRequireDefault(require("../_helpers/foreach"));

var _forown = _interopRequireDefault(require("../_helpers/forown"));

var _assign = _interopRequireDefault(require("../_helpers/assign"));

var _removebinding = _interopRequireDefault(require("./_removebinding"));

var _dom = _interopRequireDefault(require("../_dom"));

// unbinds a node
function unbindNode(object, key, node, eventOptions) {
  if ((0, _typeof2["default"])(this) === 'object' && this.isSeemple) {
    // when context is Seemple instance, use this as an object and shift other args

    /* eslint-disable no-param-reassign */
    eventOptions = node;
    node = key;
    key = object;
    object = this;
    /* eslint-enable no-param-reassign */
  } else {
    // throw error when object type is wrong
    (0, _checkobjecttype["default"])(object, 'unbindNode');
  }

  if (key instanceof Array) {
    if (typeof key[0] === 'string') {
      /*
             * accept array of keys
             * this.unbindNode(['a', 'b', 'c'], node)
             */
      (0, _foreach["default"])(key, function (itemKey) {
        return unbindNode(object, itemKey, node, eventOptions);
      });
    } else {
      /*
             * acept array of objects
             * this.unbindNode([{ key, node, binder, event }], { silent: true });
             */
      (0, _foreach["default"])(key, function (_ref) {
        var itemKey = _ref.key,
            itemNode = _ref.node,
            itemEventOptions = _ref.event;
        var commonEventOptions = node;
        var mergedEventOptions = {};

        if (commonEventOptions) {
          // extend event object by "global" event
          (0, _assign["default"])(mergedEventOptions, commonEventOptions);
        }

        if (itemEventOptions) {
          // extend event object by "local" event ("event" key of an object)
          (0, _assign["default"])(mergedEventOptions, itemEventOptions);
        }

        unbindNode(object, itemKey, itemNode, mergedEventOptions);
      });
    }

    return object;
  }

  if (key && (0, _typeof2["default"])(key) === 'object') {
    (0, _forown["default"])(key, function (keyObjValue, keyObjKey) {
      if (keyObjValue.constructor === Object && 'node' in keyObjValue) {
        // this.unbindNode({ key: { node: $(), binder } ) }, { silent: true });
        unbindNode(object, keyObjKey, keyObjValue.node, node);
      } else if (keyObjValue.constructor === Array && keyObjValue.length && keyObjValue[0].constructor === Object && 'node' in keyObjValue[0]) {
        // this.unbindNode({ key: [{ node: $(), binder }] ) }, { silent: true });
        (0, _foreach["default"])(keyObjValue, function (keyObjValueItem) {
          unbindNode(object, keyObjKey, keyObjValueItem.node, node);
        });
      } else {
        // this.unbindNode({ key: $() }, { silent: true });
        unbindNode(object, keyObjKey, keyObjValue, node);
      }
    });
    return object;
  }

  eventOptions = eventOptions || {}; // eslint-disable-line no-param-reassign

  var _eventOptions = eventOptions,
      deep = _eventOptions.deep;

  var def = _defs["default"].get(object);

  if (!def) {
    return object;
  }

  var props = def.props; // allow to pass null or undefined as key
  // if passed then remove bindings of all keys for given object

  if (key === null || typeof key === 'undefined') {
    (0, _forown["default"])(props, function (propsItem, propsKey) {
      unbindNode(object, propsKey, null, eventOptions);
    });
    return object;
  } // remove delegated binding


  if (deep !== false) {
    var deepPath = key.split('.');
    var deepPathLength = deepPath.length;

    if (deepPathLength > 1) {
      var target = object;

      for (var i = 0; i < deepPathLength - 1; i++) {
        // TODO: Do we need to throw an error when a target is falsy?
        target = target[deepPath[i]];
      } // TODO: Potential bug! This may undelegate listener for all bindings with the same path
      // ...(cannot reproduce)


      (0, _removetreelistener["default"])(object, deepPath.slice(0, deepPathLength - 2));
      unbindNode(target, deepPath[deepPathLength - 1], node, eventOptions);
      return object;
    }
  }

  var propDef = props[key]; // when no propdef do nothing

  if (!propDef) {
    return object;
  }

  var bindings = propDef.bindings; // if the property doesn't have any bindings do nothing

  if (!bindings) {
    return object;
  } // if no node is pased remove all bindings for given key


  if (!node) {
    (0, _foreach["default"])(bindings, function (binding) {
      (0, _removebinding["default"])({
        object: object,
        key: key,
        eventOptions: eventOptions,
        binding: binding
      });
    });
    propDef.bindings = null; // update nodes and $nodes for Seemple instance

    if (object.isSeemple) {
      delete object.nodes[key];
      delete object.$nodes[key];
    }

    return object;
  }

  var $nodes = (0, _getnodes["default"])(object, node);
  var retainBindings = [];
  var retainNodes = []; // iterate over all bindngs and compare their node with given nodes

  (0, _foreach["default"])($nodes, function (nodesItem) {
    (0, _foreach["default"])(bindings, function (binding) {
      if (binding.node === nodesItem) {
        (0, _removebinding["default"])({
          object: object,
          key: key,
          eventOptions: eventOptions,
          binding: binding
        });
      } else {
        retainBindings.push(binding);
        retainNodes.push(nodesItem);
      }
    });
  }); // update nodes and $nodes for Seemple instance

  if (object.isSeemple) {
    if (retainNodes.length) {
      object.nodes[key] = retainNodes[0];
      object.$nodes[key] = _dom["default"].$(retainNodes);
    } else {
      delete object.nodes[key];
      delete object.$nodes[key];
    }
  } // update bindings object


  if (retainBindings.length) {
    propDef.bindings = retainBindings;
  } else {
    propDef.bindings = null;
  }

  return object;
}
//# sourceMappingURL=index.js.map